// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7 (swiftlang-5.7.0.123.8 clang-1400.0.29.50)
// swift-module-flags: -target x86_64-apple-ios13.6-macabi -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name SoulverCore
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Foundation
@_exported import SoulverCore
import Swift
import _Concurrency
import _StringProcessing
public protocol TokenMetadata {
}
public struct URLTokenMetadata : SoulverCore.TokenMetadata {
  public var url: Foundation.URL
}
public struct DynamicVariableTokenMetadata : SoulverCore.TokenMetadata {
  public let dynamicVariable: SoulverCore.DynamicVariable
  public let value: SoulverCore.CalculationResult
}
public struct Airport : Swift.Codable, Swift.Hashable, Swift.Equatable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.Airport, b: SoulverCore.Airport) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct Timespan : Swift.Equatable {
  public let dateComponents: Foundation.DateComponents
  public static func == (a: SoulverCore.Timespan, b: SoulverCore.Timespan) -> Swift.Bool
}
open class StandardEvaluator : SoulverCore.Evaluator {
  public init(customization: SoulverCore.EngineCustomization)
  open func evaluate(_ tokenList: SoulverCore.TokenList) -> SoulverCore.EvaluationResult
  public func preprocessed(tokenList: SoulverCore.TokenList) -> SoulverCore.TokenList
  public func expressionForEvaluationFrom(tokenList: SoulverCore.TokenList) -> SoulverCore.RawExpression
  public func evaluationResultFor(resultString: Swift.String) -> SoulverCore.EvaluationResult
  public func evaluationResultFor(string: Swift.String, with variables: SoulverCore.VariableList) -> SoulverCore.EvaluationResult
  @objc deinit
}
final public class VariableList : Swift.CustomDebugStringConvertible, Swift.Equatable, Swift.Hashable {
  public init()
  convenience public init(variableList: SoulverCore.VariableList)
  convenience public init(variables: [SoulverCore.Variable])
  final public func provideDefinitionsForValuesWith(definitionBlock: (SoulverCore.RawExpression) -> SoulverCore.CalculationResult)
  final public func allVariables() -> [SoulverCore.Variable]
  final public func variablesExludingLineReferences() -> [SoulverCore.Variable]
  final public func singleWordVariables() -> [SoulverCore.Variable]
  final public func multiWordVariables(reverseSortByLength: Swift.Bool) -> [SoulverCore.Variable]
  final public func setVariable(_ variable: SoulverCore.Variable)
  final public func setVariables(_ variables: [SoulverCore.Variable])
  final public func clearVariable(withName name: Swift.String)
  final public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: SoulverCore.VariableList, rhs: SoulverCore.VariableList) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  final public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.Decimal {
  public var doubleValue: Swift.Double {
    get
  }
}
public typealias LineIndex = Swift.Int
@_hasMissingDesignatedInitializers final public class LineSheet : Swift.Codable {
  final public var copy: SoulverCore.LineSheet {
    get
  }
  final public subscript(index: SoulverCore.LineIndex) -> SoulverCore.Line {
    get
    set
  }
  final public var allLineReferences: [SoulverCore.LineIndex : SoulverCore.LineReference] {
    get
  }
  required public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
  final public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
public struct Multiplier : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public static func == (a: SoulverCore.Multiplier, b: SoulverCore.Multiplier) -> Swift.Bool
}
public struct Laptime : Swift.Equatable {
  public static func == (a: SoulverCore.Laptime, b: SoulverCore.Laptime) -> Swift.Bool
}
public typealias PrototypeExpression = Swift.String
public enum PrototypeExpressionMatchType {
  case matchLiteralString
  case matchTokenType
  case matchUnitType
  public static func == (a: SoulverCore.PrototypeExpressionMatchType, b: SoulverCore.PrototypeExpressionMatchType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias PrototypeExpressionMatchTypeHandler = (SoulverCore.Token) -> SoulverCore.PrototypeExpressionMatchType
@_hasMissingDesignatedInitializers public class PrototypeExpressionGenerator {
  public class func prototypeStringFrom(expression: SoulverCore.RawExpression, matchTypeHandler: (SoulverCore.Token) -> SoulverCore.PrototypeExpressionMatchType) -> SoulverCore.PrototypeExpression
  public class func validCustomFunctionPrototypeStringFrom(expression: SoulverCore.RawExpression, matchTypeHandler: (SoulverCore.Token) -> SoulverCore.PrototypeExpressionMatchType) -> SoulverCore.PrototypeExpression?
  @objc deinit
}
public enum FunctionIdentifier : Swift.String, Swift.CaseIterable, Swift.Codable, Swift.RawRepresentable {
  case halfOf
  case lesserOf
  case greaterOf
  case midpoint
  case proportionsFindNumerator
  case proportionsFindDenominator
  case remainder
  case dividedBy
  case makeRandomNumber
  case gcd
  case lcm
  case squareRoot
  case cubedRoot
  case nthRoot
  case nthLog
  case nthLogReversed
  case percentOf
  case percentOff
  case percentOn
  case isPercentOfWhat
  case isPercentOffWhat
  case isPercentOnWhat
  case isPercentOfWhatClassic
  case isPercentOffWhatClassic
  case isPercentOnWhatClassic
  case isWhatPercentOf
  case isWhatPercentOff
  case isWhatPercentOn
  case reversedPercentOf
  case reversedPercentOff
  case reversedPercentOn
  case isWhatMultiplierOf
  case isWhatMultiplierOn
  case isWhatMultiplierOff
  case salesTaxIn
  case xToYIsWhatPercentage
  case xToYIsWhatMultiplier
  case xToY
  case exponentialGrowth
  case exponentialDecay
  case timeRequiredForExponentialChange
  case growthOverExponentialChange
  case calendarUnitBetweenDates
  case inclusiveCalendarUnitBetweenDates
  case intervalBetweenDates
  case inclusiveIntervalBetweenDates
  case calendarUnitToDate
  case calendarUnitSinceDate
  case calendarUnitInDate
  case calendarUnitToDatespan
  case calendarUnitInDatespan
  case calendarUnitExpressionAgo
  case calendarUnitExpressionBeforeDate
  case calendarUnitExpressionAfterDate
  case halfwayBetweenDates
  case weekdayAfterTimespan
  case weekNumberOnDate
  case weekOfYear
  case dayOfWeekOnDate
  case timeInTimezone
  case dateInTimezone
  case differenceBetweenTimezones
  case generateTimestamp
  case formFrametime
  case framesToFrametime
  case intervalBetweenTimestamps
  case intervalBetweenLaptimes
  case framesBetweenFrametimes
  case intervalBetweenFrametimes
  case unitConversion
  case unitInUnitExpression
  case unitInTimespan
  case rateUnitChange
  case rateForADuration
  case substanceWeightToVolumeConversion
  case densityOfSubstance
  case speedForTime
  case powerAtRotation
  case presentValue
  case returnOnInvestmentAfter
  case returnOnInvestment
  case totalInterestOnLoanRepayment
  case annualInterestOnLoanRepayment
  case monthlyInterestOnLoanRepayment
  case totalLoanRepayment
  case annualLoanRepayment
  case monthlyLoanRepayment
  case compoundInterest
  case compoundInterestCompoundingMonthly
  case dollarWorthAdjustedForInflation
  case predictedDollarWorthGivenInflation
  case screenDensity
  case tyreSpeed
  case statisticOfList
  case statisticOfTag
  case scrubNumberWithSpecifiedRange
  public var returnType: SoulverCore.TokenType? {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SoulverCore.FunctionIdentifier]
  public typealias RawValue = Swift.String
  public static var allCases: [SoulverCore.FunctionIdentifier] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class LineCollectionCompletions {
  public class func completionsFor(textFragment: Swift.String, charIndex: Swift.Int, onLineAtIndex lineIndex: SoulverCore.LineIndex, in lineCollection: SoulverCore.LineCollection) -> [Swift.String]
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LocaleProvider {
  public class func localeWith(identifier: Swift.String) -> Foundation.Locale
  @objc deinit
}
public typealias Scalar = Swift.String
public enum DatestampType {
  case clockTime
  case utcTime
  case nakedDayOfMonth
  case nakedMonth
  case nakedYear
  case dayAndMonth
  case monthAndYear
  case dayMonthYear
  case dayMonthYearWithClockTimeDownToSeconds
  case dayMonthYearWithClockTimeDownToSubSeconds
  case weekDay
  case weekdayWithClockTime
  case relativeWeekday
  case now
  case today
  case tomorrow
  case yesterday
  case nextWeek
  case nextMonth
  case nextYear
  case lastWeek
  case lastYear
  case lastMonth
  case thisWeek
  case thisYear
  case thisMonth
  case quarter
  case unixTimestamp
  case unspecified
  public static func == (a: SoulverCore.DatestampType, b: SoulverCore.DatestampType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Datestamp : Swift.Equatable {
  public init(date: Foundation.Date, type: SoulverCore.DatestampType, timezone: Foundation.TimeZone, hasExplicitTimeComponent: Swift.Bool, hasExplicitTimeZone: Swift.Bool, isAmbiguous: Swift.Bool = false)
  public let date: Foundation.Date
  public var type: SoulverCore.DatestampType
  public var timezone: Foundation.TimeZone
  public let hasExplicitTimeComponent: Swift.Bool
  public let hasExplicitTimeZone: Swift.Bool
  public let isAmbiguous: Swift.Bool
  public static func == (a: SoulverCore.Datestamp, b: SoulverCore.Datestamp) -> Swift.Bool
}
public struct LineCollectionArchive : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class LineCollectionArchiver {
  public class func encode(lineCollection: SoulverCore.LineCollection) -> Foundation.Data?
  public class func decode(encodedLineSheet: Foundation.Data, withCustomization customization: SoulverCore.EngineCustomization, preferredLocale locale: Foundation.Locale, defaultLineFormatting: SoulverCore.FormattingPreferences?, baseVariables: SoulverCore.VariableList?, customEvaluator: SoulverCore.Evaluator? = nil) throws -> SoulverCore.LineCollection
  public class func archiveFor(lineCollection: SoulverCore.LineCollection) -> SoulverCore.LineCollectionArchive
  public class func lineCollectionFrom(archive: SoulverCore.LineCollectionArchive, withCustomization customization: SoulverCore.EngineCustomization, preferredLocale locale: Foundation.Locale) -> SoulverCore.LineCollection
  @objc deinit
}
public struct CustomUnit : Swift.Hashable, Swift.Equatable, Swift.Codable {
  public let name: Swift.String
  public let definition: Foundation.Decimal
  public let equivalentUnit: SoulverCore.UnitIdentifier
  public let legacyDefinition: Swift.String?
  public init(name: Swift.String, definition: Foundation.Decimal, equivalentUnit: SoulverCore.UnitIdentifier)
  public init(from decoder: Swift.Decoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.CustomUnit, b: SoulverCore.CustomUnit) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.DataPoint {
  public static var number: SoulverCore.DataPoint<SoulverCore.NumberFromTokenParser> {
    get
  }
  public static var binaryNumber: SoulverCore.DataPoint<SoulverCore.BinaryNumberFromTokenParser> {
    get
  }
  public static var hexNumber: SoulverCore.DataPoint<SoulverCore.HexNumberFromTokenParser> {
    get
  }
  public static var date: SoulverCore.DataPoint<SoulverCore.DateFromTokenParser> {
    get
  }
  public static var iso8601: SoulverCore.DataPoint<SoulverCore.iso8601FromTokenParser> {
    get
  }
  public static var unixTimestamp: SoulverCore.DataPoint<SoulverCore.UnixTimestampFromTokenParser> {
    get
  }
  public static var percentage: SoulverCore.DataPoint<SoulverCore.PercentageFromTokenParser> {
    get
  }
  public static var boolean: SoulverCore.DataPoint<SoulverCore.BooleanFromTokenParser> {
    get
  }
  public static var place: SoulverCore.DataPoint<SoulverCore.PlaceFromTokenParser> {
    get
  }
  public static var airport: SoulverCore.DataPoint<SoulverCore.AirportFromTokenParser> {
    get
  }
  public static var timeZone: SoulverCore.DataPoint<SoulverCore.TimeZoneFromTokenParser> {
    get
  }
  public static var currencyCode: SoulverCore.DataPoint<SoulverCore.CurrencyCodeFromTokenParser> {
    get
  }
  public static var currency: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var time: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var distance: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var temperature: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var weight: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var area: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var speed: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var volume: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var fileSize: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var fileTransferSpeed: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var fuelEconomy: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var fuelConsumption: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var pressure: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var frequency: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var power: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var angle: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static func unitOf(_ type: SoulverCore.UnitType) -> SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser>
  public static var timespan: SoulverCore.DataPoint<SoulverCore.TimespanFromTokenParser> {
    get
  }
  public static var laptime: SoulverCore.DataPoint<SoulverCore.LaptimeFromTokenParser> {
    get
  }
  public static var timecode: SoulverCore.DataPoint<SoulverCore.TimecodeFromTokenParser> {
    get
  }
  public static var url: SoulverCore.DataPoint<SoulverCore.URLFromTokenParser> {
    get
  }
  public static var hashtag: SoulverCore.DataPoint<SoulverCore.HashtagFromTokenParser> {
    get
  }
  public static var whitespace: SoulverCore.DataPoint<SoulverCore.WhitespaceFromTokenParser> {
    get
  }
  public static var screenResolution: SoulverCore.DataPoint<SoulverCore.ScreenResolutionFromTokenParser> {
    get
  }
  public static var substance: SoulverCore.DataPoint<SoulverCore.SubstanceFromTokenParser> {
    get
  }
  public static var pitch: SoulverCore.DataPoint<SoulverCore.PitchFromTokenParser> {
    get
  }
}
public struct NumberFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.Decimal
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.NumberFromTokenParser.DataType?
}
public struct BinaryNumberFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.UInt
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.UInt?
}
public struct HexNumberFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.UInt
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.UInt?
}
public struct DateFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.Date
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.DateFromTokenParser.DataType?
}
public struct PercentageFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.Decimal
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.PercentageFromTokenParser.DataType?
}
public struct URLFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.URL
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.URLFromTokenParser.DataType?
}
public struct WhitespaceFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.String
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.WhitespaceFromTokenParser.DataType?
}
public struct BooleanFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.Bool
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.Bool?
}
public struct PlaceFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Place
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Place?
}
public struct HashtagFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.String
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.String?
}
public struct SubstanceFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Substance
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Substance?
}
public struct AirportFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Place
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Place?
}
public struct TimeZoneFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Place
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Place?
}
public struct TimespanFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Timespan
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Timespan?
}
public struct LaptimeFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Laptime
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Laptime?
}
public struct TimecodeFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Frametime
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Frametime?
}
public struct CurrencyCodeFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.CurrencyCode
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.CurrencyCode?
}
public struct UnitOfTypeFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.UnitExpression
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.UnitExpression?
}
public struct ScreenResolutionFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Resolution
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Resolution?
}
public struct iso8601FromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.Date
  public func parseDataFrom(token: SoulverCore.Token) -> Foundation.Date?
}
public struct UnixTimestampFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.TimeInterval
  public func parseDataFrom(token: SoulverCore.Token) -> Foundation.TimeInterval?
}
public struct PitchFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Pitch
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Pitch?
}
final public class Line : Swift.Codable {
  final public var expression: Swift.String
  final public var behaviour: SoulverCore.LineCalculationBehaviour
  final public var skipStatistics: Swift.Bool
  final public var lineReference: SoulverCore.LineReference?
  final public var formattingPreferences: SoulverCore.FormattingPreferences?
  final public var expressionAlignment: SoulverCore.LineExpressionAlignment
  final public var highlight: SoulverCore.LineHighlightColor?
  final public var result: SoulverCore.CalculationResult?
  final public var parsedExpression: SoulverCore.TokenList?
  final public var apparentLineType: SoulverCore.ApparentLineType?
  final public var lineIndex: SoulverCore.LineIndex?
  final public var explicitDependencies: Foundation.IndexSet?
  final public var variableEnvironment: SoulverCore.VariableList?
  final public var rawResult: Swift.String {
    get
  }
  final public var formattedResult: Swift.String {
    get
  }
  convenience public init(_ expression: SoulverCore.RawExpression)
  public init()
  required public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
extension SoulverCore.Line {
  final public var isSubtotal: Swift.Bool {
    get
  }
  final public var isHeading: Swift.Bool {
    get
  }
  final public var isDivider: Swift.Bool {
    get
  }
}
extension SoulverCore.Line {
  final public var declaredVariable: SoulverCore.Variable? {
    get
  }
  final public func referencesInExpressionTo(variable: SoulverCore.Variable) -> [SoulverCore.Token]
  final public var indexesReferencedInExpression: Foundation.IndexSet {
    get
  }
}
extension SoulverCore.Line : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: SoulverCore.Line, rhs: SoulverCore.Line) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public static var EmptyLine: SoulverCore.Line {
    get
  }
  final public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.Line : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
public enum ApparentLineType {
  case regular
  case comment
  case header
  case variableDeclaration
  case divider
  public static func == (a: SoulverCore.ApparentLineType, b: SoulverCore.ApparentLineType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum LineCalculationBehaviour : Swift.String, Swift.Codable {
  case evaluatesExpression
  case sumsLinesAbove
  case definesFunction
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum LineExpressionAlignment : Swift.String, Swift.Codable {
  case left
  case center
  case right
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum LineHighlightColor : Swift.String, Swift.Codable, Swift.RawRepresentable {
  case red
  case orange
  case yellow
  case green
  case blue
  case purple
  case grey
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias PitchNotation = Swift.String
public struct Pitch : Swift.Equatable {
  public static func == (a: SoulverCore.Pitch, b: SoulverCore.Pitch) -> Swift.Bool
}
extension SoulverCore.DataPoint : _StringProcessing.CustomConsumingRegexComponent {
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: T.DataType)?
  public typealias RegexOutput = T.DataType
}
public struct Substance : Swift.Equatable {
  public let name: Swift.String
  public let value: Foundation.Decimal
  public var rateValue: SoulverCore.UnitRate {
    get
  }
  public static func == (a: SoulverCore.Substance, b: SoulverCore.Substance) -> Swift.Bool
}
public enum StatisticType : Swift.Int, Swift.RawRepresentable {
  case total
  case average
  case count
  case median
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum TokenType : Swift.CaseIterable {
  case number
  case `operator`
  case percentageSymbol
  case converterSymbol
  case unit
  case bracket
  case whitespace
  case variable
  case dynamicVariable
  case equals
  case pi
  case typeName
  case conditionalKeyword
  case conjunctionWord
  case prepositionWord
  case grammerArticleWord
  case function
  case timezone
  case substance
  case comma
  case dot
  case quotationMark
  case colon
  case hash
  case questionMark
  case label
  case fraction
  case binaryNumber
  case hexadecimalNumber
  case converter
  case unixTimestamp
  case datestamp
  case iso8601
  case timespan
  case laptime
  case frametime
  case datespan
  case dateWord
  case pitch
  case dateQualifier
  case ordinalSuffix
  case relativePlaceWord
  case numberWord
  case statisticType
  case unitExpression
  case compoundUnitExpression
  case nightWord
  case nightExpression
  case conditionalExpression
  case percentage
  case salesTax
  case multiplier
  case dpSpecifier
  case resolution
  case list
  case boolean
  case rate
  case functionExpression
  case wordFunction
  case variableDeclaration
  case unitDeclaration
  case conditionalVariableDeclaration
  case declaredVariable
  case declaredUnit
  case variableAssignmentOperator
  case subexpression
  case wordComment
  case hashtag
  case bracketComment
  case slashComment
  case legacyQuotationComment
  case labelExpression
  case url
  case customType
  case error
  case pending
  case failed
  case remoteQuery
  case scalar
  case unidentified
  case customInternal
  case dateComponents
  case literal
  public static func == (a: SoulverCore.TokenType, b: SoulverCore.TokenType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SoulverCore.TokenType]
  public static var allCases: [SoulverCore.TokenType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public enum TokenSubType {
  case positiveNumber
  case negativeNumber
  case additionOperator
  case subtractionOperator
  case multiplicationOperator
  case divisionOperator
  case reverseDivisionOperator
  case reverseSubtractionOperator
  case powerOperator
  case modOperator
  case lesserOf
  case greaterOf
  case greaterThan
  case greaterThanOrEqualTo
  case lessThan
  case lessThanOrEqualTo
  case equalTo
  case notEqualTo
  case logicalAndOperator
  case logicalOrOperator
  case logicalNotOperator
  case bitwiseAndOperator
  case bitwiseOrOperator
  case bitwiseXorOperator
  case bitwiseNotOperator
  case bitwiseLeftShiftOperator
  case bitwiseRightShiftOperator
  case `false`
  case `true`
  case openBracket
  case closeBracket
  case converterSymbolTo
  case converterSymbolAs
  case converterSymbolIn
  case numberConverter
  case fractionConverter
  case multiplierConveter
  case binaryConverter
  case hexadecimalConverter
  case percentageConverter
  case percentageApplier
  case unitConverter
  case unitExpressionConverter
  case rateConverter
  case dateConverter
  case iso8601Converter
  case feetAndInchesConverter
  case timestampConverter
  case timespanConverter
  case laptimeConverter
  case frametimeConverter
  case pitchConverter
  case midiConverter
  case timezoneConverter
  case roundingToDpConverter
  case roundingUpConverter
  case roundingConverter
  case roundingDownConverter
  case dateWordToday
  case dateWordNow
  case dateWordTomorrow
  case dateWordYesterday
  case dateWordDayOfWeek
  case dateWordMonthOfYear
  case dateWordQuarterOfYear
  case dateWordAm
  case dateWordPm
  case dateWordMidday
  case dateWordMidnight
  case dateWordSummer
  case dateWordAutumn
  case dateWordWinter
  case dateWordSpring
  case dateQualifierNext
  case dateQualifierThis
  case dateQualifierPrevious
  case relativePlaceWordHere
  case statisticWordTotal
  case statisticWordAverage
  case statisticWordCount
  case statisticWordMedian
  case prepositionWordFrom
  case prepositionWordSince
  case prepositionWordOf
  case prepositionWordAt
  case prepositionWordFor
  case definiteGrammarArticleWord
  case indefiniteGrammarArticleWord
  case conjunctionWordAnd
  case conjunctionWordOr
  case numberTypeName
  case fractionTypeName
  case multiplierTypeName
  case binaryTypeName
  case hexadecimalTypeName
  case percentageTypeName
  case rateTypeName
  case timestampTypeName
  case timespanTypeName
  case feetAndInchesTypeName
  case laptimeTypeName
  case frametimeTypeName
  case dateTypeName
  case iso8601TypeName
  case decimalPlacesTypeName
  case midiTypeName
  case pitchTypeName
  case builtInWordFunction
  case customWordFunction
  case conditionalKeywordIf
  case conditionalKeywordThen
  case conditionalKeywordElse
  case conditionalKeywordUnless
  case unitMismatchError
  case infinityError
  case divideByZeroError
  case imaginaryNumberError
  case unsupportedUnitMultiplication
  case unsupportedRate
  case badDivision
  case unknownError
  case notSpecified
  public static func == (a: SoulverCore.TokenSubType, b: SoulverCore.TokenSubType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct TokenTypeSet {
  public init(types: Swift.Set<SoulverCore.TokenType>)
  public let types: Swift.Set<SoulverCore.TokenType>
  public var count: Swift.Int {
    get
  }
  public func contains(_ tokenType: SoulverCore.TokenType) -> Swift.Bool
  public static let randomWords: SoulverCore.TokenTypeSet
}
public protocol RoutineOwner : AnyObject {
  func routineCompleted(routine: SoulverCore.Routine)
}
public protocol Routine : AnyObject {
  var routineOwner: SoulverCore.RoutineOwner? { get set }
  func go()
  func goWithCompletionBlock(completion: @escaping (() -> Swift.Void))
}
extension SoulverCore.Routine {
  public func goWithCompletionBlock(completion: @escaping (() -> Swift.Void))
}
public struct CalculationResult : Swift.Equatable {
  public let stringValue: Swift.String
  public let evaluationResult: SoulverCore.EvaluationResult
  public let parsedExpression: SoulverCore.TokenList?
  public static func == (a: SoulverCore.CalculationResult, b: SoulverCore.CalculationResult) -> Swift.Bool
}
extension SoulverCore.CalculationResult {
  public var isEmptyResult: Swift.Bool {
    get
  }
  public var isPendingResult: Swift.Bool {
    get
  }
  public var isFailedResult: Swift.Bool {
    get
  }
}
public var EmptyResult: SoulverCore.CalculationResult {
  get
}
public var PendingResult: SoulverCore.CalculationResult {
  get
}
public var FailedResult: SoulverCore.CalculationResult {
  get
}
public struct EngineFeatureFlags : Swift.Hashable, Swift.Equatable {
  public init()
  public var units: Swift.Bool
  public var calendarCalculations: Swift.Bool
  public var wordFunctions: Swift.Bool
  public var subexpressions: Swift.Bool
  public var disabledUnits: Swift.Set<SoulverCore.UnitIdentifier>?
  public var disabledFunctions: Swift.Set<SoulverCore.FunctionIdentifier>?
  public var variableDeclarations: Swift.Bool
  public var unitDeclarations: Swift.Bool
  public var hexAndBinary: Swift.Bool
  public var bitwiseOperators: Swift.Bool
  public var cookingSubstances: Swift.Bool
  public var musicalConversions: Swift.Bool
  public var hashTags: Swift.Bool
  public var nights: Swift.Bool
  public var bracketComments: Swift.Bool
  public var quotationMarkComments: Swift.Bool
  public var slashComments: Swift.Bool
  public var labelComments: Swift.Bool
  public var seeksFutureDate: Swift.Bool
  public var preserveAllParsedTokenTypes: Swift.Bool
  public var remoteQueries: Swift.Bool
  public var inAmbiguityPreferSomethingToNothing: Swift.Bool
  public var leftToRightOperatorEvaluation: Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.EngineFeatureFlags, b: SoulverCore.EngineFeatureFlags) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public let UntokenizedLineReference: Swift.String
@_hasMissingDesignatedInitializers public class SCUnit : Swift.Equatable, Swift.Hashable, Swift.CustomDebugStringConvertible {
  final public let identifier: SoulverCore.UnitIdentifier
  final public let symbol: Swift.String
  public var baseUnitValue: Foundation.Decimal {
    get
  }
  public var baseUnit: SoulverCore.SCUnit {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: SoulverCore.SCUnit, rhs: SoulverCore.SCUnit) -> Swift.Bool
  open class func baseUnit() -> SoulverCore.SCUnit
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.SCUnit {
  public var unitType: SoulverCore.UnitType {
    get
  }
}
public typealias UID = Swift.String
public struct LineReference : Swift.Equatable, Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible {
  public let UID: SoulverCore.UID
  public init(UID: SoulverCore.UID)
  public var description: Swift.String {
    get
  }
  public static func == (a: SoulverCore.LineReference, b: SoulverCore.LineReference) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct List {
}
extension Swift.Array where Element : Swift.Equatable {
  public func doesNotContain(_ element: Element) -> Swift.Bool
}
extension Swift.Collection {
  public var isNotEmpty: Swift.Bool {
    get
  }
}
extension Swift.Array {
  public subscript(safe index: Swift.Array<Element>.Index) -> Element? {
    get
  }
  public var lastIndex: Swift.Int? {
    get
  }
  public func isValid(index: Swift.Int) -> Swift.Bool
  public mutating func trim(where predicate: (Element) throws -> Swift.Bool)
  public mutating func move(from oldIndex: Swift.Array<Element>.Index, to newIndex: Swift.Array<Element>.Index)
  public mutating func extract(_ shouldExtract: (Element) -> Swift.Bool) -> [Element]
}
public enum EvaluationError : Swift.Error {
  case UnitMismatch
  case UnsupportedUnitMultiplication
  case UnsupportedRate
  case Infinity
  case ImaginaryNumber
  case DivideByZero
  case BadDivision
  case Other
  public static func == (a: SoulverCore.EvaluationError, b: SoulverCore.EvaluationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum LineStyle : Swift.Int {
  case normal
  case heading
  case label
  case comment
  case divider
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class LineStyler {
  public static let MARKDOWN_HEADING_CHARACTER: Swift.String
  public static let HEADING_INDICATOR: Swift.String
  public static let COMMENT_INDICATOR: Swift.String
  public static let LABEL_INDICATOR: Swift.String
  public static let LINE_DIVIDER_CHARACTER: Swift.String
  public init()
  final public func lineStyleFor(expression: Swift.String) -> SoulverCore.LineStyle
  final public func style(expression: Swift.String, with style: SoulverCore.LineStyle) -> Swift.String
  final public func entireLabelRangeIn(_ expression: Swift.String) -> Foundation.NSRange?
  final public func labelRangeIn(_ expression: Swift.String) -> Foundation.NSRange?
  final public func dividerRangeIn(_ expression: Swift.String) -> Foundation.NSRange?
  final public func headingIndicatorRangeIn(_ expression: Swift.String) -> Foundation.NSRange?
  final public func headingRangeIn(_ expression: Swift.String) -> Foundation.NSRange?
  public static var defaultLabel: Swift.String {
    get
  }
  @objc deinit
}
public struct ExportOptions {
  public var plainTextSeparator: Swift.String
  public var useUnformattedResults: Swift.Bool
  public var substituteLineReferences: Swift.Bool
  public var includeAnswers: Swift.Bool
  public init()
}
@_hasMissingDesignatedInitializers public class LineCollectionExporter {
  public class func jsonDataFor(lineCollection: SoulverCore.LineCollection) -> Foundation.Data?
  public class func csvDataFor(lineCollection: SoulverCore.LineCollection, options: SoulverCore.ExportOptions) -> Foundation.Data?
  public class func textFor(lineCollection: SoulverCore.LineCollection, options: SoulverCore.ExportOptions) -> Swift.String
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LineCollectionEnumerator {
  public typealias EnumerationExpression = Swift.String
  public typealias EnumerationResult = Swift.String
  public enum ReferenceSubstituionPolicy {
    case dontSubstitue
    case formattedResult
    case plainTextReference
    case markdownLinkStyle
    public static func == (a: SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy, b: SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ResultFormatting {
    case formatted
    case raw
    public static func == (a: SoulverCore.LineCollectionEnumerator.ResultFormatting, b: SoulverCore.LineCollectionEnumerator.ResultFormatting) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct LineCollectionEnumerationOptions {
    public var referenceSubstitutionPolicy: SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy
    public var resultFormatting: SoulverCore.LineCollectionEnumerator.ResultFormatting
    public var reversed: Swift.Bool
    public init()
  }
  public typealias LineCollectionStringEnumerationHandler = ((SoulverCore.LineIndex, SoulverCore.LineCollectionEnumerator.EnumerationExpression, SoulverCore.LineCollectionEnumerator.EnumerationResult, inout Swift.Bool) -> Swift.Void)
  public typealias LineCollectionModelEnumerationHandler = ((SoulverCore.LineIndex, SoulverCore.TokenList, SoulverCore.CalculationResult?, inout Swift.Bool) -> Swift.Void)
  public class func enumerateStringsIn(lineCollection: SoulverCore.LineCollection, with options: SoulverCore.LineCollectionEnumerator.LineCollectionEnumerationOptions = LineCollectionEnumerationOptions(), in handler: (SoulverCore.LineIndex, SoulverCore.LineCollectionEnumerator.EnumerationExpression, SoulverCore.LineCollectionEnumerator.EnumerationResult, inout Swift.Bool) -> Swift.Void)
  public class func enumerateModelsIn(lineCollection: SoulverCore.LineCollection, with options: SoulverCore.LineCollectionEnumerator.LineCollectionEnumerationOptions = LineCollectionEnumerationOptions(), in modelHandler: (SoulverCore.LineIndex, SoulverCore.TokenList, SoulverCore.CalculationResult?, inout Swift.Bool) -> Swift.Void)
  public class func enumerateStringsIn<T>(lineCollection: SoulverCore.LineCollection, with options: SoulverCore.LineCollectionEnumerator.LineCollectionEnumerationOptions = LineCollectionEnumerationOptions(), in handler: ((SoulverCore.LineIndex, SoulverCore.LineCollectionEnumerator.EnumerationExpression, SoulverCore.LineCollectionEnumerator.EnumerationResult) -> T?)) -> T?
  @objc deinit
}
public struct iso8601 : Swift.Equatable {
  public let datestamp: SoulverCore.Datestamp
  public static func == (a: SoulverCore.iso8601, b: SoulverCore.iso8601) -> Swift.Bool
}
public enum UnitType : Swift.String, Swift.CaseIterable, Swift.Codable {
  case acceleration
  case amountOfSubstance
  case angle
  case angularVelocity
  case area
  case concentrationMass
  case currency
  case dataStorage
  case dataTransfer
  case dispersion
  case duration
  case electricCharge
  case electricCurrent
  case electricPotential
  case electricResistance
  case electricConductance
  case electricalInductance
  case electricalCapacitance
  case magneticFlux
  case magneticFluxDensity
  case energy
  case force
  case frameRate
  case frames
  case frequency
  case fuelConsumption
  case fuelEconomy
  case illuminance
  case length
  case mass
  case other
  case power
  case pressure
  case screenDensity
  case speed
  case substanceConcentraion
  case temperature
  case torque
  case volume
  public var label: Swift.String {
    get
  }
  public var baseUnitIdentifier: SoulverCore.UnitIdentifier {
    get
  }
  public var associatedOtherUnits: [SoulverCore.UnitIdentifier] {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SoulverCore.UnitType]
  public typealias RawValue = Swift.String
  public static var allCases: [SoulverCore.UnitType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum UnitIdentifier : Swift.String, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable {
  case arcMinutes
  case arcSeconds
  case radians
  case gradians
  case revolutions
  case squareMegameters
  case squareKilometers
  case squareMeters
  case squareCentimeters
  case squareMillimeters
  case squareMicrometers
  case squareNanometers
  case squareInches
  case squareFeet
  case squareYards
  case squareMiles
  case acres
  case ares
  case hectares
  case litersPerKilometer
  case litersPer100Kilometers
  case milesPerImperialGallon
  case milesPerGallon
  case gramsPerLiter
  case kilometersPerLiter
  case seconds
  case minutes
  case hours
  case days
  case weekdays
  case nights
  case weeks
  case months
  case years
  case picoseconds
  case nanoseconds
  case microseconds
  case milliseconds
  case joules
  case kilojoules
  case megajoules
  case gigajoules
  case kilocalories
  case calories
  case wattSeconds
  case wattMinutes
  case wattHours
  case kilowattHours
  case megawattHours
  case gigawattHours
  case terawattHours
  case terahertz
  case gigahertz
  case megahertz
  case kilohertz
  case hertz
  case millihertz
  case microhertz
  case nanohertz
  case framesPerSecond
  case radiansPerSecond
  case revolutionsPerSecond
  case revolutionsPerMinute
  case megameters
  case hectokilometers
  case kilometers
  case hectometers
  case decameters
  case meters
  case decimeters
  case centimeters
  case millimeters
  case micrometers
  case nanometers
  case picometers
  case inches
  case feet
  case yards
  case miles
  case scandinavianMiles
  case lightyears
  case astronomicalUnits
  case nauticalMiles
  case fathoms
  case furlongs
  case parsecs
  case lux
  case kilograms
  case grams
  case decigrams
  case centigrams
  case milligrams
  case micrograms
  case nanograms
  case picograms
  case ounces
  case pounds
  case stones
  case metricTons
  case shortTons
  case carats
  case ouncesTroy
  case slugs
  case terawatts
  case gigawatts
  case megawatts
  case kilowatts
  case watts
  case milliwatts
  case microwatts
  case nanowatts
  case picowatts
  case femtowatts
  case horsepower
  case pascals
  case gigapascals
  case megapascals
  case kilopascals
  case hectopascals
  case inchesOfMercury
  case atmospheres
  case bars
  case millibars
  case millimetersOfMercury
  case poundsForcePerSquareInch
  case kilopoundsForcePerSquareInch
  case megapoundsForcePerSquareInch
  case metersPerSecond
  case feetPerSecond
  case kilometersPerHour
  case milesPerHour
  case knots
  case kelvin
  case celsius
  case fahrenheit
  case liters
  case kiloliters
  case megaliters
  case milliliters
  case microliters
  case centiliters
  case deciliters
  case cubicKilometers
  case cubicMeters
  case cubicDecimeters
  case cubicCentimeters
  case cubicMillimeters
  case cubicInches
  case cubicFeet
  case cubicYards
  case cubicMiles
  case acreFeet
  case bushels
  case teaspoons
  case tablespoons
  case fluidOunces
  case cups
  case pints
  case quarts
  case gallons
  case imperialTeaspoons
  case imperialTablespoons
  case imperialFluidOunces
  case imperialPints
  case imperialQuarts
  case imperialGallons
  case metricCups
  case metricTeaspoons
  case metricTablespoons
  case metricAUTablespoons
  case ppi
  case pixel
  case em
  case point
  case frames
  case milligramsPerDeciliter
  case partsPerMillion
  case moles
  case millimoles
  case micromoles
  case nanomoles
  case molar
  case newtons
  case kilonewtons
  case meganewtons
  case giganewtons
  case millinewtons
  case micronewtons
  case nanonewtons
  case poundals
  case poundsOfForce
  case ouncesOfForce
  case newtonMeters
  case poundFeet
  case poundInches
  case ounceInches
  case metersPerSecondSquared
  case feetPerSecondSquared
  case gravity
  case degrees
  case coulombs
  case megaampereHours
  case kiloampereHours
  case ampereHours
  case milliampereHours
  case microampereHours
  case megaamperes
  case kiloamperes
  case amperes
  case milliamperes
  case microamperes
  case megavolts
  case kilovolts
  case volts
  case millivolts
  case microvolts
  case megaohms
  case kiloohms
  case ohms
  case milliohms
  case microohms
  case siemens
  case kilosiemens
  case megasiemens
  case millisiemens
  case microsiemens
  case henrys
  case kilohenrys
  case megahenrys
  case millihenrys
  case microhenrys
  case farads
  case kilofarads
  case megafarads
  case millifarads
  case microfarads
  case webers
  case kilowebers
  case megawebers
  case milliwebers
  case microwebers
  case teslas
  case kiloteslas
  case megateslas
  case milliteslas
  case microteslas
  case bytes
  case bits
  case nibbles
  case yottabytes
  case zettabytes
  case exabytes
  case petabytes
  case terabytes
  case gigabytes
  case megabytes
  case kilobytes
  case yottabits
  case zettabits
  case exabits
  case petabits
  case terabits
  case gigabits
  case megabits
  case kilobits
  case yobibytes
  case zebibytes
  case exbibytes
  case pebibytes
  case tebibytes
  case gibibytes
  case mebibytes
  case kibibytes
  case yobibits
  case zebibits
  case exbibits
  case pebibits
  case tebibits
  case gibibits
  case mebibits
  case kibibits
  case bytesPerSecond
  case bitsPerSecond
  case yottabytesPerSecond
  case zettabytesPerSecond
  case exabytesPerSecond
  case petabytesPerSecond
  case terabytesPerSecond
  case gigabytesPerSecond
  case megabytesPerSecond
  case kilobytesPerSecond
  case yottabitsPerSecond
  case zettabitsPerSecond
  case exabitsPerSecond
  case petabitsPerSecond
  case terabitsPerSecond
  case gigabitsPerSecond
  case megabitsPerSecond
  case kilobitsPerSecond
  case yobibytesPerSecond
  case zebibytesPerSecond
  case exbibytesPerSecond
  case pebibytesPerSecond
  case tebibytesPerSecond
  case gibibytesPerSecond
  case mebibytesPerSecond
  case kibibytesPerSecond
  case yobibitsPerSecond
  case zebibitsPerSecond
  case exbibitsPerSecond
  case pebibitsPerSecond
  case tebibitsPerSecond
  case gibibitsPerSecond
  case mebibitsPerSecond
  case kibibitsPerSecond
  case currencyADA
  case currencyAED
  case currencyAFN
  case currencyALL
  case currencyAMD
  case currencyANG
  case currencyAOA
  case currencyARS
  case currencyAUD
  case currencyAWG
  case currencyAZN
  case currencyBAM
  case currencyBBD
  case currencyBCH
  case currencyBDT
  case currencyBGN
  case currencyBHD
  case currencyBIF
  case currencyBMD
  case currencyBNB
  case currencyBND
  case currencyBOB
  case currencyBRL
  case currencyBSD
  case currencyBSV
  case currencyBTC
  case currencyBTN
  case currencyBWP
  case currencyBYN
  case currencyBZD
  case currencyCAD
  case currencyCDF
  case currencyCHF
  case currencyCLF
  case currencyCLP
  case currencyCNY
  case currencyCOP
  case currencyCRC
  case currencyCUC
  case currencyCVE
  case currencyCZK
  case currencyDASH
  case currencyDJF
  case currencyDKK
  case currencyDOGE
  case currencyDOP
  case currencyDZD
  case currencyEGP
  case currencyEOS
  case currencyERN
  case currencyETB
  case currencyETC
  case currencyETH
  case currencyEUR
  case currencyFJD
  case currencyFKP
  case currencyGBP
  case currencyGEL
  case currencyGGP
  case currencyGHS
  case currencyGIP
  case currencyGMD
  case currencyGNF
  case currencyGTQ
  case currencyGYD
  case currencyHKD
  case currencyHNL
  case currencyHRK
  case currencyHTG
  case currencyHUF
  case currencyIDR
  case currencyILS
  case currencyIMP
  case currencyINR
  case currencyIQD
  case currencyIRR
  case currencyISK
  case currencyJEP
  case currencyJMD
  case currencyJOD
  case currencyJPY
  case currencyKES
  case currencyKGS
  case currencyKHR
  case currencyKMF
  case currencyKPW
  case currencyKRW
  case currencyKWD
  case currencyKYD
  case currencyKZT
  case currencyLAK
  case currencyLBP
  case currencyLKR
  case currencyLRD
  case currencyLSL
  case currencyLTC
  case currencyLTL
  case currencyLVL
  case currencyLYD
  case currencyMAD
  case currencyMDL
  case currencyMGA
  case currencyMKD
  case currencyMMK
  case currencyMNT
  case currencyMOP
  case currencyMRO
  case currencyMUR
  case currencyMVR
  case currencyMWK
  case currencyMXN
  case currencyMYR
  case currencyMZN
  case currencyNAD
  case currencyNEO
  case currencyNGN
  case currencyNIO
  case currencyNOK
  case currencyNPR
  case currencyNZD
  case currencyOMR
  case currencyPAB
  case currencyPEN
  case currencyPGK
  case currencyPHP
  case currencyPKR
  case currencyPLN
  case currencyPYG
  case currencyQAR
  case currencyRON
  case currencyRSD
  case currencyRUB
  case currencyRWF
  case currencySAR
  case currencySBD
  case currencySCR
  case currencySDG
  case currencySEK
  case currencySGD
  case currencySHP
  case currencySLL
  case currencySOS
  case currencySOL
  case currencyAVAX
  case currencyLUNA
  case currencyDOT
  case currencyMATIC
  case currencySHIB
  case currencySRD
  case currencySTD
  case currencySVC
  case currencySYP
  case currencySZL
  case currencyTHB
  case currencyTJS
  case currencyTMT
  case currencyTND
  case currencyTOP
  case currencyTRX
  case currencyTRY
  case currencyTTD
  case currencyTWD
  case currencyTZS
  case currencyUAH
  case currencyUGX
  case currencyUSD
  case currencyUSDT
  case currencyUYU
  case currencyUZS
  case currencyVEF
  case currencyVND
  case currencyVUV
  case currencyWST
  case currencyXAF
  case currencyXAG
  case currencyXAU
  case currencyXCD
  case currencyXDR
  case currencyXLM
  case currencyXMR
  case currencyXOF
  case currencyXPF
  case currencyXRP
  case currencyYER
  case currencyZAR
  case currencyZMK
  case currencyZMW
  case currencyZWL
  case currencySatoshi
  case currencyDollarCents
  case currencyBritishPence
  case currencyEuroCents
  case undefined
  public var unit: SoulverCore.SCUnit {
    get
  }
  public var unitType: SoulverCore.UnitType {
    get
  }
  public var motherUnitIdentifier: SoulverCore.UnitIdentifier {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SoulverCore.UnitIdentifier]
  public typealias RawValue = Swift.String
  public static var allCases: [SoulverCore.UnitIdentifier] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class ResultContextualMetadata {
  public class func humanReadableMetadataFor(formattedResult: SoulverCore.CalculationResult, customization: SoulverCore.EngineCustomization) -> Swift.String?
  @objc deinit
}
extension Foundation.NumberFormatter {
  public func string(from number: Foundation.Decimal) -> Swift.String?
}
public struct LineSheetDelta {
  public let indexesAdded: Foundation.IndexSet
  public let indexesDeleted: Foundation.IndexSet
  public let indexesModified: Foundation.IndexSet
  public var isSingleLineEdit: Swift.Bool {
    get
  }
}
extension Foundation._NSRange {
  public static var zero: Foundation.NSRange {
    get
  }
}
public typealias TokenIndex = Swift.Int
public struct TokenIndexPath : Swift.Equatable {
  public let tokenIndex: SoulverCore.TokenIndex
  public let lineIndex: SoulverCore.LineIndex
  public init(tokenIndex: SoulverCore.TokenIndex, lineIndex: SoulverCore.LineIndex)
  public static func == (a: SoulverCore.TokenIndexPath, b: SoulverCore.TokenIndexPath) -> Swift.Bool
}
public typealias CurrencyCode = Swift.String
@_hasMissingDesignatedInitializers public class CurrencyList : SoulverCore.CurrencyRateProvider {
  public func rateFor(request: SoulverCore.CurrencyRateRequest) -> Foundation.Decimal?
  public static let realWorldCurrencies: Swift.Set<SoulverCore.UnitIdentifier>
  public static let cryptoCurrencies: Swift.Set<SoulverCore.UnitIdentifier>
  public static let commodities: Swift.Set<SoulverCore.UnitIdentifier>
  public static let fractionalCurrencies: Swift.Set<SoulverCore.UnitIdentifier>
  public class func unitIdentifierFor(code: SoulverCore.CurrencyCode) -> SoulverCore.UnitIdentifier?
  public class func currencyCodeFor(unitIdentifier: SoulverCore.UnitIdentifier) -> SoulverCore.CurrencyCode?
  @objc deinit
}
extension Swift.String {
  public func foundationLocalized() -> Swift.String
  public func localized(bundle: Foundation.Bundle = .main) -> Swift.String
}
public enum SIThreshold : Swift.String {
  case septillion
  case sextillion
  case quintillion
  case quadrillion
  case trillion
  case billion
  case million
  case hundredThousand
  case thousand
  case hecto
  case deca
  case centi
  case milli
  case micro
  case nano
  case pico
  case femto
  case atto
  case zetto
  case yocto
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
indirect public enum EvaluationResult {
  case rawString(Swift.String)
  case decimal(Foundation.Decimal)
  case percentage(SoulverCore.Percentage)
  case fraction(SoulverCore.Fraction)
  case binary(Swift.UInt)
  case hex(Swift.UInt)
  case multiplier(SoulverCore.Multiplier)
  case boolean(Swift.Bool)
  case unitExpression(SoulverCore.UnitExpression)
  case rate(SoulverCore.UnitRate)
  case date(SoulverCore.Datestamp)
  case iso8601(SoulverCore.iso8601)
  case timestamp(SoulverCore.Timestamp)
  case timespan(SoulverCore.Timespan)
  case laptime(SoulverCore.Laptime)
  case frametime(SoulverCore.Frametime)
  case resolution(SoulverCore.Resolution)
  case salesTax(SoulverCore.SalesTax)
  case pitch(SoulverCore.Pitch)
  case nightExpression(SoulverCore.NightExpression)
  case error(SoulverCore.EvaluationError)
  case variable(SoulverCore.Variable)
  case datespan(SoulverCore.Datespan)
  case unit(SoulverCore.SCUnit)
  case substance(SoulverCore.Substance)
  case place(SoulverCore.Place)
  case customType(SoulverCore.CustomType)
  case statisticType(SoulverCore.StatisticType)
  case list(SoulverCore.List)
  case pending
  case failed
  case none
  public var stringValue: Swift.String? {
    get
  }
  public var equivalentTokenType: SoulverCore.TokenType {
    get
  }
  public var decimalValue: Foundation.Decimal? {
    get
  }
  public var unitExpressionValue: SoulverCore.UnitExpression? {
    get
  }
  public var datestampValue: SoulverCore.Datestamp? {
    get
  }
  public var nightExpressionValue: SoulverCore.NightExpression? {
    get
  }
  public var placeValue: SoulverCore.Place? {
    get
  }
  public var unitValue: SoulverCore.SCUnit? {
    get
  }
  public var substanceValue: SoulverCore.Substance? {
    get
  }
  public var rateValue: SoulverCore.UnitRate? {
    get
  }
}
extension SoulverCore.EvaluationResult : Swift.Equatable {
  public static func == (lhs: SoulverCore.EvaluationResult, rhs: SoulverCore.EvaluationResult) -> Swift.Bool
}
public enum DatespanType {
  case season
  case quarter
  case dateInterval
  public static func == (a: SoulverCore.DatespanType, b: SoulverCore.DatespanType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum DatespanSubtype {
  case summer
  case autumn
  case winter
  case spring
  case firstQuarter
  case secondQuarter
  case thirdQuarter
  case fourthQuarter
  case notSpecified
  public static func == (a: SoulverCore.DatespanSubtype, b: SoulverCore.DatespanSubtype) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Datespan : Swift.Equatable {
  public static func == (a: SoulverCore.Datespan, b: SoulverCore.Datespan) -> Swift.Bool
}
public typealias CustomFunctionHandler = (_ parameters: [SoulverCore.EvaluationResult]) -> SoulverCore.EvaluationResult
#if compiler(>=5.3) && $AsyncAwait
public typealias BackgroundCustomFunctionHandler = (_ parameters: [SoulverCore.EvaluationResult]) async throws -> SoulverCore.EvaluationResult
#endif
public typealias PrototypePlaceholder = Swift.String
public struct CustomType : Swift.Hashable, Swift.Equatable {
  public init(prototypePlaceholder: SoulverCore.PrototypePlaceholder, symbols: [Swift.String], associatedObject: Any?)
  public let prototypePlaceholder: SoulverCore.PrototypePlaceholder
  public let symbols: [Swift.String]
  public let associatedObject: Any?
  public static func == (lhs: SoulverCore.CustomType, rhs: SoulverCore.CustomType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CustomFunction : Swift.Hashable, Swift.Equatable {
  public init(prototypeExpression: SoulverCore.PrototypeExpression, handler: @escaping SoulverCore.CustomFunctionHandler)
  public var backgroundHandler: SoulverCore.BackgroundCustomFunctionHandler?
  public var customTypes: [SoulverCore.CustomType]?
  public var aliases: [SoulverCore.PrototypeExpression]?
  public var prerequisiteTypes: SoulverCore.TokenTypeSet?
  public static func == (lhs: SoulverCore.CustomFunction, rhs: SoulverCore.CustomFunction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Int {
  public func compare(_ other: Swift.Int) -> Foundation.ComparisonResult
}
public typealias DynamicVariableDefinitonBlock = (_ variableList: SoulverCore.VariableList) -> SoulverCore.CalculationResult
public struct DynamicVariable : Swift.Hashable, Swift.Equatable {
  public enum DynamicVariableType {
    case undefined
    case distantValue
    case subsheet
    case functionParameter
    public static func == (a: SoulverCore.DynamicVariable.DynamicVariableType, b: SoulverCore.DynamicVariable.DynamicVariableType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(symbol: Swift.String, type: SoulverCore.DynamicVariable.DynamicVariableType = .undefined, handler: @escaping SoulverCore.DynamicVariableDefinitonBlock)
  public let type: SoulverCore.DynamicVariable.DynamicVariableType
  public let name: Swift.String
  public let handler: SoulverCore.DynamicVariableDefinitonBlock
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: SoulverCore.DynamicVariable, rhs: SoulverCore.DynamicVariable) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Evaluator : AnyObject {
  func evaluate(_ tokenList: SoulverCore.TokenList) -> SoulverCore.EvaluationResult
}
public enum TokenListForm : Swift.Equatable {
  case singleNumber(value: Foundation.Decimal)
  case singleUnitExpression(value: SoulverCore.UnitExpression)
  case singleDatestamp(value: SoulverCore.Datestamp)
  case conversion(fromUnit: SoulverCore.SCUnit, toUnit: SoulverCore.SCUnit, quantity: Foundation.Decimal)
  case dateSeeking(startDate: SoulverCore.Datestamp, timespan: SoulverCore.Timespan, direction: Foundation.Calendar.SearchDirection)
  case unitUntilDateSeeking(unit: SoulverCore.SCUnit, toDate: SoulverCore.Datestamp)
  case intervalBetweenDatesSeeking(startDate: SoulverCore.Datestamp, endDate: SoulverCore.Datestamp, unit: SoulverCore.SCUnit?)
  case timeAtPlaceSeeking(place: SoulverCore.Place)
  case timeDifferenceBetweenPlacesSeeking(firstPlace: SoulverCore.Place, secondPlace: SoulverCore.Place)
  case timeConversionToPlace(fromDate: SoulverCore.Datestamp, toPlace: SoulverCore.Place)
  case other
  public static func == (a: SoulverCore.TokenListForm, b: SoulverCore.TokenListForm) -> Swift.Bool
}
public struct TokenListMetadata {
  public let form: SoulverCore.TokenListForm
}
extension SoulverCore.TokenList {
  final public var metadata: SoulverCore.TokenListMetadata {
    get
  }
}
final public class Calculator {
  final public var customization: SoulverCore.EngineCustomization {
    get
  }
  final public var formattingPreferences: SoulverCore.FormattingPreferences?
  public init(customization: SoulverCore.EngineCustomization)
  final public func calculate(_ expression: Swift.String, with variableList: SoulverCore.VariableList? = nil) -> SoulverCore.CalculationResult
  #if compiler(>=5.3) && $AsyncAwait
  final public func calculateInBackground(_ expression: Swift.String, with variableList: SoulverCore.VariableList? = nil) async -> SoulverCore.CalculationResult
  #endif
  @objc deinit
}
extension SoulverCore.Calculator {
  public static var basic: SoulverCore.Calculator {
    get
  }
  final public func dateFor(_ expression: Swift.String, with variableList: SoulverCore.VariableList? = nil) -> (date: Foundation.Date, result: SoulverCore.CalculationResult)?
}
extension Swift.Collection where Self.Element == Swift.String {
  public func find<T>(_ find: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current) -> [T.DataType] where T : SoulverCore.DataFromTokenParser
  public func find<T, U>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, locale: Foundation.Locale = .current) -> [(T.DataType, U.DataType)] where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser
  public func find<T, U, Y>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<Y>, locale: Foundation.Locale = .current) -> [(T.DataType, U.DataType, Y.DataType)] where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, Y : SoulverCore.DataFromTokenParser
  public func find<T, U, V, W>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<V>, _ entity4: SoulverCore.DataPoint<W>, locale: Foundation.Locale = .current) -> [(T.DataType, U.DataType, V.DataType, W.DataType)] where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, V : SoulverCore.DataFromTokenParser, W : SoulverCore.DataFromTokenParser
  public func find<T, U, V, W, X>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<V>, _ entity4: SoulverCore.DataPoint<W>, _ entity5: SoulverCore.DataPoint<X>, locale: Foundation.Locale = .current) -> [(T.DataType, U.DataType, V.DataType, W.DataType, X.DataType)] where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, V : SoulverCore.DataFromTokenParser, W : SoulverCore.DataFromTokenParser, X : SoulverCore.DataFromTokenParser
  public func find<T, U, V, W, X, Y>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<V>, _ entity4: SoulverCore.DataPoint<W>, _ entity5: SoulverCore.DataPoint<X>, _ entity6: SoulverCore.DataPoint<Y>, locale: Foundation.Locale = .current) -> [(T.DataType, U.DataType, V.DataType, W.DataType, X.DataType, Y.DataType)] where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, V : SoulverCore.DataFromTokenParser, W : SoulverCore.DataFromTokenParser, X : SoulverCore.DataFromTokenParser, Y : SoulverCore.DataFromTokenParser
}
extension Swift.Collection where Self.Element == Swift.String {
  public func replacingAll<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current, replacement: ((T.DataType) -> Swift.String?)) -> [Swift.String] where T : SoulverCore.DataFromTokenParser
  public func replacingFirst<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current, replacement: ((T.DataType) -> Swift.String?)) -> [Swift.String] where T : SoulverCore.DataFromTokenParser
}
public class LineCollectionReducer {
  public var inflectCustomUnits: Swift.Bool
  public init(lineCollection: SoulverCore.LineCollection)
  public var returnValue: SoulverCore.CalculationResult {
    get
  }
  public var locallyDefinedVariables: [SoulverCore.Variable] {
    get
  }
  public var locallyDefinedUnits: [SoulverCore.CustomUnit] {
    get
  }
  public struct CustomDefinitions {
    public let customVariables: [SoulverCore.Variable]
    public let customUnits: [SoulverCore.CustomUnit]
    public let inflectedCustomUnits: [SoulverCore.CustomUnit]
    public let customPlaces: [SoulverCore.Place]
    public let customFunctions: [SoulverCore.CustomFunction]
  }
  public var customDefinitions: SoulverCore.LineCollectionReducer.CustomDefinitions {
    get
  }
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class AsynchronousOperation : Foundation.Operation {
  @objc override dynamic public var isAsynchronous: Swift.Bool {
    @objc get
  }
  @objc override dynamic public var isExecuting: Swift.Bool {
    @objc get
  }
  @objc override dynamic public var isFinished: Swift.Bool {
    @objc get
  }
  @objc override dynamic public func start()
  @objc override dynamic open func main()
  public func finish()
  public enum State : Swift.String {
    case ready
    case executing
    case finished
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var state: SoulverCore.AsynchronousOperation.State {
    get
    set
  }
  @objc override dynamic public init()
  @objc deinit
}
extension SoulverCore.Token {
  public var number: Foundation.Decimal? {
    get
  }
  public var scalar: SoulverCore.Scalar? {
    get
  }
  public var decimalValue: Foundation.Decimal {
    get
  }
  public var binaryValue: Swift.UInt? {
    get
  }
  public var hexValue: Swift.UInt? {
    get
  }
  public var resolutionValue: SoulverCore.Resolution? {
    get
  }
  public var salesTaxValue: SoulverCore.SalesTax? {
    get
  }
  public var percentageValue: SoulverCore.Percentage {
    get
  }
  public var unitExpressionValue: SoulverCore.UnitExpression? {
    get
  }
  public var unitValue: SoulverCore.SCUnit? {
    get
  }
  public var calendarComponentValue: Foundation.Calendar.Component? {
    get
  }
  public var rateValue: SoulverCore.UnitRate? {
    get
  }
  public var datestampValue: SoulverCore.Datestamp? {
    get
  }
  public var datespanValue: SoulverCore.Datespan? {
    get
  }
  public var dateComponentsValue: Foundation.DateComponents? {
    get
  }
  public var placeValue: SoulverCore.Place? {
    get
  }
  public var pitchValue: SoulverCore.Pitch? {
    get
  }
  public var timeZoneValue: Foundation.TimeZone? {
    get
  }
  public var fractionValue: SoulverCore.Fraction? {
    get
  }
  public var timespanValue: SoulverCore.Timespan? {
    get
  }
  public var booleanValue: Swift.Bool {
    get
  }
  public var laptimeValue: SoulverCore.Laptime? {
    get
  }
  public var frametimeValue: SoulverCore.Frametime? {
    get
  }
  public var errorValue: SoulverCore.EvaluationError? {
    get
  }
  public var variable: SoulverCore.Variable? {
    get
  }
  public var dynamicVariable: SoulverCore.DynamicVariable? {
    get
  }
  public var statisticType: SoulverCore.StatisticType? {
    get
  }
  public var isLineReference: Swift.Bool {
    get
  }
  public var isVariable: Swift.Bool {
    get
  }
  public var functionIdentifier: SoulverCore.FunctionIdentifier? {
    get
  }
}
public struct SalesTax : Swift.Equatable {
  public init(decimalValue: Foundation.Decimal)
  public let decimalValue: Foundation.Decimal
  public static func == (a: SoulverCore.SalesTax, b: SoulverCore.SalesTax) -> Swift.Bool
}
public struct Resolution {
  public let width: Foundation.Decimal
  public let height: Foundation.Decimal
}
public struct Percentage : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public init(value: Foundation.Decimal)
  public static func == (a: SoulverCore.Percentage, b: SoulverCore.Percentage) -> Swift.Bool
}
public struct Timestamp : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public static func == (a: SoulverCore.Timestamp, b: SoulverCore.Timestamp) -> Swift.Bool
}
public typealias VariableName = Swift.String
public typealias VariableValue = Swift.String
public enum VariableType : Swift.String, Swift.RawRepresentable, Swift.Codable {
  case undefined
  case local
  case global
  case lineReference
  case relativeLineReference
  case tag
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct Variable : Swift.Codable {
  public let name: SoulverCore.VariableName
  public let value: SoulverCore.VariableValue?
  public init(name: SoulverCore.VariableName, value: SoulverCore.VariableValue?, type: SoulverCore.VariableType = .undefined)
  public var definition: SoulverCore.EvaluationResult?
  public var type: SoulverCore.VariableType
  public var isPhrase: Swift.Bool?
  public var declaringLineIndex: SoulverCore.LineIndex?
  public var relatedLineIndexes: Foundation.IndexSet?
  public var representedResults: [SoulverCore.EvaluationResult]?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension SoulverCore.Variable : Swift.Hashable, Swift.Equatable {
  public static func == (lhs: SoulverCore.Variable, rhs: SoulverCore.Variable) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Foundation.IndexSet {
  public func isJust(_ integer: Swift.Int) -> Swift.Bool
  public var onlyFirst: Foundation.IndexSet {
    get
  }
  public var removingFirstIndex: Foundation.IndexSet {
    get
  }
  public var smartDescription: Swift.String {
    get
  }
  public var secondLastIndex: Swift.Int? {
    get
  }
}
public struct Holiday : Swift.Hashable, Swift.Equatable, Swift.Codable {
  public init(day: Swift.Int, month: Swift.Int, year: Swift.Int)
  public let day: Swift.Int
  public let month: Swift.Int
  public let year: Swift.Int
  public var description: Swift.String?
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.Holiday, b: SoulverCore.Holiday) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
extension SoulverCore.Holiday {
  public func isOnSameDayAs(otherHoliday: SoulverCore.Holiday) -> Swift.Bool
}
public struct Place : Swift.Hashable, Swift.Equatable {
  public enum PlaceType : Swift.Equatable, Swift.Hashable {
    case country(country: SoulverCore.Country)
    case city(city: SoulverCore.City)
    case airport(airport: SoulverCore.Airport)
    case timeZoneAbbreviation
    case unspecified
    public static func == (a: SoulverCore.Place.PlaceType, b: SoulverCore.Place.PlaceType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(name: Swift.String, aliases: [Swift.String]?, timeZone: Foundation.TimeZone, type: SoulverCore.Place.PlaceType = .unspecified)
  public let name: Swift.String
  public let aliases: [Swift.String]?
  public let timeZone: Foundation.TimeZone
  public let type: SoulverCore.Place.PlaceType
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.Place, b: SoulverCore.Place) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ExpressionBeautificationOptions {
  public var quickOperators: Swift.Bool
  public var autoThousandsSeparators: Swift.Bool
  public var allowsOrphanedThousandsSeparators: Swift.Bool
  public var padStandardOperators: Swift.Bool
  public var fancyTimes: Swift.Bool
  public var fancyMinus: Swift.Bool
  public var collapseSpaces: Swift.Bool
  public var formatsSlashCommentsWithSpaces: Swift.Bool
  public static var defaults: SoulverCore.ExpressionBeautificationOptions {
    get
  }
  public init()
}
public struct UnitRate {
  public let value: Foundation.Decimal
  public let ofUnit: SoulverCore.SCUnit?
  public let perUnit: SoulverCore.SCUnit
}
extension SoulverCore.UnitRate : Swift.Comparable {
  public static func < (lhs: SoulverCore.UnitRate, rhs: SoulverCore.UnitRate) -> Swift.Bool
  public static func == (a: SoulverCore.UnitRate, b: SoulverCore.UnitRate) -> Swift.Bool
}
extension SoulverCore.UnitRate : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SoulverCore.UnitExpression : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public class LineCollectionVariableDiffer {
  public struct VariableDiff {
    public let originalName: Swift.String
    public let newName: Swift.String
  }
  public init(lineCollection: SoulverCore.LineCollection)
  public func determineVariableNameChanges() -> [SoulverCore.LineCollectionVariableDiffer.VariableDiff]
  @objc deinit
}
public struct Frametime : Swift.Equatable {
  public static func == (a: SoulverCore.Frametime, b: SoulverCore.Frametime) -> Swift.Bool
}
public class EvaluationResultFormatter {
  public init(customization: SoulverCore.EngineCustomization, formattingPreferences: SoulverCore.FormattingPreferences?)
  public func format(result: SoulverCore.EvaluationResult) -> SoulverCore.CalculationResult
  @objc deinit
}
infix operator ~ : AdditionPrecedence
public struct WhileEscape {
  public init(maximumCycles: Swift.Int)
  public mutating func increment()
  public var shouldBreak: Swift.Bool {
    get
  }
}
@_hasMissingDesignatedInitializers public class LineCollectionFuser {
  public class func fusingTokensOfTypes(_ tokenTypeSet: SoulverCore.TokenTypeSet, from lineCollection: SoulverCore.LineCollection) -> SoulverCore.LineCollection
  @objc deinit
}
public typealias RawExpression = Swift.String
extension Foundation.Locale {
  public static let chineseLocalePrefix: Swift.String
  public var isChinese: Swift.Bool {
    get
  }
  public var isTraditionalChinese: Swift.Bool {
    get
  }
  public var isSimplifiedChinese: Swift.Bool {
    get
  }
  public var isAussieSpeaking: Swift.Bool {
    get
  }
  public var isRussian: Swift.Bool {
    get
  }
  public var isEngish: Swift.Bool {
    get
  }
  public var isGerman: Swift.Bool {
    get
  }
}
final public class LineCollection {
  public typealias EvaluatedLinesHandler = (_ evaluatedIndexes: Foundation.IndexSet) -> Swift.Void
  final public var lineSheet: SoulverCore.LineSheet {
    get
    set
  }
  final public var customization: SoulverCore.EngineCustomization {
    get
  }
  final public var variableList: SoulverCore.VariableList? {
    get
    set
  }
  final public var defaultLineFormattingPreferences: SoulverCore.FormattingPreferences? {
    get
    set
  }
  final public var expressionBeautificationOptions: SoulverCore.ExpressionBeautificationOptions? {
    get
    set
  }
  public init(customization: SoulverCore.EngineCustomization)
  final public var deepCopy: SoulverCore.LineCollection {
    get
  }
  final public func beginChanges()
  final public func endChangesWith(evaluationHandler: SoulverCore.LineCollection.EvaluatedLinesHandler?, dependenciesHandler: SoulverCore.LineCollection.EvaluatedLinesHandler?)
  @discardableResult
  final public func addLine(_ expression: Swift.String = "") -> SoulverCore.Line
  final public func setLinesWithExpressions(_ expressions: [SoulverCore.RawExpression])
  final public func insertLineBelow(lineIndex: SoulverCore.LineIndex, with expression: Swift.String)
  final public func insertLineAt(lineIndex: SoulverCore.LineIndex, withExpression expression: Swift.String)
  final public func insert(line: SoulverCore.Line, at lineIndex: SoulverCore.LineIndex)
  final public func moveLineAt(lineIndex: SoulverCore.LineIndex, toLineIndex: SoulverCore.LineIndex)
  final public func removeLineAt(lineIndex: SoulverCore.LineIndex)
  final public func replaceLineAt(lineIndex: SoulverCore.LineIndex, with newLine: SoulverCore.Line)
  final public subscript(index: SoulverCore.LineIndex) -> SoulverCore.Line {
    get
    set(newValue)
  }
  final public subscript(safe index: SoulverCore.LineIndex) -> SoulverCore.Line? {
    get
  }
  final public func setExpression(expression: Swift.String, forLineAt index: SoulverCore.LineIndex)
  final public func setFormatting(formattingPreferences: SoulverCore.FormattingPreferences)
  final public func setFormatting(formattingPreferences: SoulverCore.FormattingPreferences?, forLineAt index: SoulverCore.LineIndex)
  final public func setAlignment(alignment: SoulverCore.LineExpressionAlignment, forLineAt index: SoulverCore.LineIndex)
  final public func setHighlight(highlight: SoulverCore.LineHighlightColor?, forLineAt index: SoulverCore.LineIndex)
  final public func setBehaviour(behaviour: SoulverCore.LineCalculationBehaviour, forLineAt index: SoulverCore.LineIndex)
  final public func cancelPendingAnswer(forLineAt lineIndex: SoulverCore.LineIndex)
  final public func evaluateAll()
  final public func evaluateLinesAt(indexes: Foundation.IndexSet, dependenciesUpdatedHandler: SoulverCore.LineCollection.EvaluatedLinesHandler? = nil)
  @discardableResult
  final public func makeReferenceForLineAt(lineIndex: SoulverCore.LineIndex) -> SoulverCore.LineReference
  final public func clearReferenceForLineAt(lineIndex: SoulverCore.LineIndex)
  @discardableResult
  final public func observeEvaluationWith(handler: @escaping SoulverCore.LineCollection.EvaluatedLinesHandler) -> SoulverCore.LineCollectionObserverToken
  final public func remove(observer: SoulverCore.LineCollectionObserverToken)
  final public func calculateQuickStatistic(statisticType: SoulverCore.StatisticType, limitToIndexes: Foundation.IndexSet? = nil, ignoreVariableDeclaration: Swift.Bool = true, ignoreReferencedLines: Swift.Bool = true) -> SoulverCore.CalculationResult?
  final public var quickSum: SoulverCore.CalculationResult? {
    get
  }
  final public var quickAverage: SoulverCore.CalculationResult? {
    get
  }
  final public var quickCount: SoulverCore.CalculationResult? {
    get
  }
  final public func quickSumOf(indexes: Foundation.IndexSet) -> SoulverCore.CalculationResult?
  final public func quickAverageOf(indexes: Foundation.IndexSet) -> SoulverCore.CalculationResult?
  final public func quickCountOf(indexes: Foundation.IndexSet) -> SoulverCore.CalculationResult?
  @discardableResult
  final public func convertToLocale(_ toLocale: Foundation.Locale) -> Swift.Bool
  final public func set(customization: SoulverCore.EngineCustomization)
  final public func performChanges(performBlock: ((SoulverCore.LineCollection) -> Swift.Void)) -> SoulverCore.LineCollectionStateTicket
  @discardableResult
  final public func revertToStateWith(ticket: SoulverCore.LineCollectionStateTicket) -> SoulverCore.LineSheetDelta?
  final public func clearStates()
  final public var lineCount: Swift.Int {
    get
  }
  final public func isValidIndex(_ lineIndex: SoulverCore.LineIndex) -> Swift.Bool
  final public func areValidIndexes(_ indexes: Foundation.IndexSet) -> Swift.Bool
  final public var allIndexes: Foundation.IndexSet {
    get
  }
  final public var lastIndex: Swift.Int {
    get
  }
  final public var firstIndex: Swift.Int {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var lines: [SoulverCore.Line] {
    get
  }
  final public func linesAtIndexes(indexes: Foundation.IndexSet) -> [SoulverCore.Line]
  final public func variableListForLineAtIndex(_ lineIndex: SoulverCore.LineIndex) -> SoulverCore.VariableList
  final public func tokenFor(tokenIndexPath: SoulverCore.TokenIndexPath) -> SoulverCore.Token?
  final public func isValidLineReference(UID: SoulverCore.UID, onLineAt lineIndex: SoulverCore.LineIndex) -> Swift.Bool
  final public func lineForLineReference(lineReference: SoulverCore.LineReference) -> SoulverCore.Line?
  final public func lineFor(_ lineReferenceVariable: SoulverCore.Variable) -> SoulverCore.Line?
  final public func formattedDefinitionOf(inlineVariable: SoulverCore.Variable) -> Swift.String?
  @discardableResult
  final public func replaceOccurancesInExpressions(replacements: [Swift.String : Swift.String]) -> Foundation.IndexSet
  final public func unformattedResultFor(lineIndex: SoulverCore.LineIndex) -> Swift.String
  final public var customEvaluator: SoulverCore.Evaluator? {
    get
    set
  }
  final public func addSubsheet(reference: SoulverCore.LineReference? = nil) -> SoulverCore.LineReference
  final public func set(content lineSheet: SoulverCore.LineSheet, forSubsheetWith reference: SoulverCore.LineReference)
  final public func contentForSubsheetWith(reference: SoulverCore.LineReference) -> SoulverCore.LineSheet?
  final public func makeReferenceForDynamicSymbol() -> SoulverCore.LineReference
  @objc deinit
}
public typealias LineCollectionStateTicket = Swift.String
extension SoulverCore.LineCollection : Swift.CustomDebugStringConvertible {
  public typealias MultiLineText = Swift.String
  final public class func textViewReadyLineCollectionWith(customization: SoulverCore.EngineCustomization) -> SoulverCore.LineCollection
  convenience public init(multiLineText: SoulverCore.LineCollection.MultiLineText, customization: SoulverCore.EngineCustomization? = nil)
  public static var basic: SoulverCore.LineCollection {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class LineCollectionObserverToken : Swift.Hashable, Swift.Equatable {
  public static func == (lhs: SoulverCore.LineCollectionObserverToken, rhs: SoulverCore.LineCollectionObserverToken) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.LineCollection {
  final public var indexesOfTimeDependentLines: Foundation.IndexSet {
    get
  }
  final public func indexesOfLinesDependentOn(variables: [SoulverCore.Variable]) -> Foundation.IndexSet
  final public var indexesOfPendingLines: Foundation.IndexSet {
    get
  }
}
@_hasMissingDesignatedInitializers public class LineCollectionIterator : Swift.IteratorProtocol {
  public typealias Element = SoulverCore.Line
  public func next() -> SoulverCore.Line?
  @objc deinit
}
extension SoulverCore.LineCollection : Swift.Sequence {
  final public func makeIterator() -> SoulverCore.LineCollectionIterator
  public typealias Element = SoulverCore.LineCollectionIterator.Element
  public typealias Iterator = SoulverCore.LineCollectionIterator
}
extension SoulverCore.LineCollection {
  final public var text: SoulverCore.LineCollection.MultiLineText {
    get
  }
}
public struct UnitExpression {
  public let value: Foundation.Decimal
  public let unit: SoulverCore.SCUnit
  public func convertedTo(unit identifier: SoulverCore.UnitIdentifier) -> SoulverCore.UnitExpression?
}
extension SoulverCore.UnitExpression {
  public static func with(unit: SoulverCore.UnitIdentifier, and value: Foundation.Decimal) -> SoulverCore.UnitExpression
}
extension SoulverCore.UnitExpression : Swift.Comparable {
  public static func == (lhs: SoulverCore.UnitExpression, rhs: SoulverCore.UnitExpression) -> Swift.Bool
  public static func < (lhs: SoulverCore.UnitExpression, rhs: SoulverCore.UnitExpression) -> Swift.Bool
}
extension SoulverCore.UnitExpression : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.SCUnit {
  public var prefersZeroDP: Swift.Bool {
    get
  }
  public var prefersThreeDP: Swift.Bool {
    get
  }
}
indirect public enum NightExpressionContext : Swift.Equatable {
  case lastDate(date: Foundation.Date)
  case lastNightExpression(nightExpression: SoulverCore.NightExpression)
  case firstNightExpression(nightExpression: SoulverCore.NightExpression)
  public static func == (a: SoulverCore.NightExpressionContext, b: SoulverCore.NightExpressionContext) -> Swift.Bool
}
public struct NightExpression : Swift.Equatable {
  public static func == (a: SoulverCore.NightExpression, b: SoulverCore.NightExpression) -> Swift.Bool
}
public struct EngineCustomization : Swift.Equatable, Swift.Hashable {
  public let locale: Foundation.Locale
  public let calendar: Foundation.Calendar
  public var timeZone: Foundation.TimeZone {
    get
  }
  public var customUnits: [SoulverCore.CustomUnit]
  public var currencyRateProvider: SoulverCore.CurrencyRateProvider?
  public var customSymbols: [SoulverCore.UnitSymbolReplacement]
  public var customPlaces: [SoulverCore.Place]
  public var customFunctions: [SoulverCore.CustomFunction]
  public var dynamicVariables: [SoulverCore.DynamicVariable]
  public var holidays: [SoulverCore.Holiday]
  public var unitSystem: SoulverCore.UnitMeasurementSystem
  public var featureFlags: SoulverCore.EngineFeatureFlags
  public init(locale: Foundation.Locale, calendar: Foundation.Calendar? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: SoulverCore.EngineCustomization, rhs: SoulverCore.EngineCustomization) -> Swift.Bool
  public static var standard: SoulverCore.EngineCustomization {
    get
  }
  public func convertTo(locale: Foundation.Locale) -> SoulverCore.EngineCustomization
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.EngineCustomization {
  public static func standardWith(locale: Foundation.Locale) -> SoulverCore.EngineCustomization
  public func isOperator(text: Swift.String) -> Swift.Bool
  public func longFormNameFor(unitIdentifier: SoulverCore.UnitIdentifier) -> Swift.String?
  public func symbolFor(unitIdentifier: SoulverCore.UnitIdentifier) -> Swift.String?
}
extension SoulverCore.EngineCustomization : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct CurrencyRateRequest {
  public let unitIdentifier: SoulverCore.UnitIdentifier
  public let currencyCode: Swift.String
  public let baseCurrencyCode: Swift.String
  public let baseCurrencyQuantity: Swift.Double
}
public protocol CurrencyRateProvider : AnyObject {
  func rateFor(request: SoulverCore.CurrencyRateRequest) -> Foundation.Decimal?
}
public typealias PrivateUnicodeSymbol = Swift.String
@_hasMissingDesignatedInitializers public class SingleCharacterUIDGenerator {
  public class func isUID(symbol: SoulverCore.PrivateUnicodeSymbol) -> Swift.Bool
  public class func parameterIndexFor(UID: SoulverCore.PrivateUnicodeSymbol) -> Swift.Int?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class StaticResouces {
  public static var localizedStandardPlaces: [SoulverCore.Place] {
    get
  }
  public static var localizedCountries: [SoulverCore.Country] {
    get
  }
  public static var localizedCities: [SoulverCore.City] {
    get
  }
  @objc deinit
}
public enum UnitSymbolReplacementPosition : Swift.String, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable {
  case before
  case beforeWithSpace
  case after
  case afterWithSpace
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SoulverCore.UnitSymbolReplacementPosition]
  public typealias RawValue = Swift.String
  public static var allCases: [SoulverCore.UnitSymbolReplacementPosition] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct UnitSymbolReplacement : Swift.Equatable, Swift.Hashable, Swift.Codable {
  public let originalSymbol: Swift.String
  public let replacementSymbol: Swift.String
  public let position: SoulverCore.UnitSymbolReplacementPosition
  public init(original: Swift.String, replacement: Swift.String, position: SoulverCore.UnitSymbolReplacementPosition = .before)
  public static func standardCustomSymbolsFor(locale: Foundation.Locale) -> [SoulverCore.UnitSymbolReplacement]
  public static func == (a: SoulverCore.UnitSymbolReplacement, b: SoulverCore.UnitSymbolReplacement) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct WordFunctionArgument {
  public let matchedToken: SoulverCore.Token
  public let functionArgument: SoulverCore.EvaluationResult
}
@_hasMissingDesignatedInitializers public class FunctionSubstitutionUtility {
  public class func functionArgumentsForCustomFunction(token: SoulverCore.Token) -> [SoulverCore.WordFunctionArgument]?
  @objc deinit
}
public class ECBCurrencyRateProvider : SoulverCore.CurrencyRateProvider {
  public init()
  public func updateRates(completionHandler: @escaping ((_ success: Swift.Bool) -> Swift.Void))
  public func rateFor(request: SoulverCore.CurrencyRateRequest) -> Foundation.Decimal?
  @objc deinit
}
extension Swift.String {
  public func removingThousandsSeparators(locale: Foundation.Locale) -> Swift.String
  public func wrappedIn(_ character: Swift.String) -> Swift.String
  public func bracketed() -> Swift.String
  public func invertedCommad() -> Swift.String
  public func spaced() -> Swift.String
  public static var standardEasternEuropeanThousandsSeparator: Swift.String
  public static var standardWhitespace: Swift.String
  public static var nonBreakingSpace: Swift.String
  public static let standardDecimalPoint: Swift.String
  public static let standardMultiplierDot: Swift.String
  public static let standardDash: Swift.String
  public static let standardHash: Swift.String
  public static let standardSlash: Swift.String
  public static let newlineSymbol: Swift.String
  public static let underscore: Swift.String
  public static let zero: Swift.String
  public var isNewline: Swift.Bool {
    get
  }
  public var firstCharacter: Swift.Character? {
    get
  }
  public var lastCharacter: Swift.Character? {
    get
  }
  public var isSingleWhitespace: Swift.Bool {
    get
  }
  public var isLowercased: Swift.Bool {
    get
  }
  public var isUppercased: Swift.Bool {
    get
  }
  public var isMixedCase: Swift.Bool {
    get
  }
  public func replaceCharactersFromSet(characterSet: Foundation.CharacterSet, replacementString: Swift.String = "") -> Swift.String
  public var whitespaceStandardized: Swift.String {
    get
  }
  public var whitespaceRemoved: Swift.String {
    get
  }
  public var whitespaceTrimmed: Swift.String {
    get
  }
  public func firstWord() -> Swift.String?
  public func lastWord() -> Swift.String?
}
extension Swift.String {
  public var completeStringRange: Foundation.NSRange {
    get
  }
  public var completeRange: Swift.Range<Swift.String.Index> {
    get
  }
  public var dirtyWordCount: Swift.Int {
    get
  }
  public var dirtyLineCount: Swift.Int {
    get
  }
  public var newLineCount: Swift.Int {
    get
  }
  public var isNotEmpty: Swift.Bool {
    get
  }
  public func removingPrefix(_ prefix: Swift.String) -> Swift.String
  public func removingSuffix(_ suffix: Swift.String) -> Swift.String
  public func addingPrefix(_ prefix: Swift.String) -> Swift.String
  public func addingSuffix(_ suffix: Swift.String) -> Swift.String
  public func characterBefore(_ index: Swift.String.Index) -> Swift.Character?
  public func characterAfter(_ index: Swift.String.Index) -> Swift.Character?
  public var lastCharaterIndex: Swift.String.Index? {
    get
  }
}
extension Swift.String {
  public func enumerateCharacters(invoking body: @escaping (Swift.String, inout Swift.Bool) -> Swift.Void)
  public func enumerateRangesOf(pattern: Swift.String, reverse: Swift.Bool, invoking body: @escaping (Foundation.NSRange) -> Swift.Void)
  public func enumerateParagraphs(invoking body: @escaping (Swift.String, inout Swift.Bool) -> Swift.Void)
  public var isSingleWord: Swift.Bool {
    get
  }
  public var isPhrase: Swift.Bool {
    get
  }
}
extension Swift.String {
  public func containsPattern(_ regex: Swift.String) -> Swift.Bool
  public func capturedGroups(with pattern: Foundation.NSRegularExpression) -> [Foundation.NSRange]
  public func capturedGroups(withRegex pattern: Swift.String) -> [Foundation.NSRange]
  public func erasingPattern(_ pattern: Swift.String) -> Swift.String
  public var trailingDigit: Swift.Int? {
    get
  }
}
extension Swift.String {
  public func containsCharacter(_ element: Swift.Character) -> Swift.Bool
  public func rangesOf(string: Swift.String) -> [Swift.Range<Swift.String.Index>]
  public func rangesOf(strings: [Swift.String]) -> [Swift.Range<Swift.String.Index>]
}
public struct NotationPreferences : Swift.Equatable, Swift.Hashable {
  public enum NotationStyle {
    case auto
    case on
    case off
    public static func == (a: SoulverCore.NotationPreferences.NotationStyle, b: SoulverCore.NotationPreferences.NotationStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var notationStyle: SoulverCore.NotationPreferences.NotationStyle
  public var upperNotationThreshold: SoulverCore.SIThreshold
  public var lowerNotationThreshold: SoulverCore.SIThreshold
  public init(notationStyle: SoulverCore.NotationPreferences.NotationStyle, upperNotationThreshold: SoulverCore.SIThreshold, lowerNotationThreshold: SoulverCore.SIThreshold)
  public static var off: SoulverCore.NotationPreferences {
    get
  }
  public static func == (a: SoulverCore.NotationPreferences, b: SoulverCore.NotationPreferences) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct FormattingPreferences : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public static var maximumDp: Swift.Int
  public var dp: Swift.Int
  public var thousandsSeparatorDisabled: Swift.Bool
  public var currencyFormattingDisabled: Swift.Bool
  public var notationPreferences: SoulverCore.NotationPreferences
  public var referencesTakeFormattedValue: Swift.Bool
  public var fractionizeWherePossible: Swift.Bool
  public init()
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: SoulverCore.FormattingPreferences, b: SoulverCore.FormattingPreferences) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Country : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public let name: Swift.String
  public let capital: Swift.String
  public let capitalCityTimezoneID: Swift.String?
  public var timeZone: Foundation.TimeZone? {
    get
  }
  public static func == (a: SoulverCore.Country, b: SoulverCore.Country) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct City : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public let identifier: Swift.String
  public let name: Swift.String
  public let timezone_id: Swift.String
  public var timeZone: Foundation.TimeZone? {
    get
  }
  public static func == (a: SoulverCore.City, b: SoulverCore.City) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct Token : Swift.Equatable, Swift.Hashable, Swift.Comparable {
  public static func == (lhs: SoulverCore.Token, rhs: SoulverCore.Token) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func < (lhs: SoulverCore.Token, rhs: SoulverCore.Token) -> Swift.Bool
  public let type: SoulverCore.TokenType
  public let subType: SoulverCore.TokenSubType
  public var stringValue: Swift.String
  public var range: Foundation.NSRange
  public var subtokens: SoulverCore.TokenList?
  public var metadata: SoulverCore.TokenMetadata?
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.Token : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SoulverCore.TokenList : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: SoulverCore.TokenList, rhs: SoulverCore.TokenList) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TokenList {
  final public var tokens: [SoulverCore.Token]
  final public var count: Swift.Int {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var flattenedTokens: [SoulverCore.Token] {
    get
  }
  final public subscript(index: Swift.Int) -> SoulverCore.Token {
    get
    set(newValue)
  }
  final public func firstToken(ofType: SoulverCore.TokenType) -> SoulverCore.Token?
  final public func lastToken(ofType: SoulverCore.TokenType) -> SoulverCore.Token?
  final public func tokensOfType(_ tokenType: SoulverCore.TokenType) -> [SoulverCore.Token]
  final public func allTokensOfType(_ tokenType: SoulverCore.TokenType, excludingTokensWhereParentIsIn parentTokenTypes: SoulverCore.TokenTypeSet = TokenTypeSet(types: [])) -> [SoulverCore.Token]
  final public func allTypesHaveBeenPresentIn(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  final public func onlyTypesHaveBeenPresentIn(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  final public func anyTypesHaveBeenPresentIn(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  final public func tokenBefore(_ token: SoulverCore.Token, mustBe type: SoulverCore.TokenType, ignoreWhitespace: Swift.Bool = true, ignoreTypes: SoulverCore.TokenTypeSet? = nil) -> SoulverCore.Token?
  final public func tokenAfter(_ token: SoulverCore.Token, mustBe type: SoulverCore.TokenType, ignoreWhitespace: Swift.Bool = true, ignoreTypes: SoulverCore.TokenTypeSet? = nil) -> SoulverCore.Token?
  final public func tokenAfter(_ token: SoulverCore.Token, mustBeIn types: SoulverCore.TokenTypeSet, ignoreWhitespace: Swift.Bool = true, ignoreTypes: SoulverCore.TokenTypeSet? = nil) -> SoulverCore.Token?
  final public func tokenBefore(_ token: SoulverCore.Token, mustBeIn types: SoulverCore.TokenTypeSet, ignoreWhitespace: Swift.Bool = true, ignoreTypes: SoulverCore.TokenTypeSet? = nil) -> SoulverCore.Token?
  final public func tokenNeighbouring(_ token: SoulverCore.Token, mustBe type: SoulverCore.TokenType, ignoreWhitespace: Swift.Bool = true, ignoreTypes: SoulverCore.TokenTypeSet? = nil) -> SoulverCore.Token?
  @objc deinit
}
extension SoulverCore.TokenList {
  final public var rebuiltExpression: SoulverCore.RawExpression {
    get
  }
}
extension SoulverCore.TokenList : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension SoulverCore.TokenList {
  final public func tokenFor(tokenIndex: SoulverCore.TokenIndex) -> SoulverCore.Token?
  final public func tokenIndexFor(token: SoulverCore.Token) -> SoulverCore.TokenIndex?
  final public func tokenFor(characterIndex: Swift.Int, ignoreWhitespace: Swift.Bool = true, endOfLineReturnsLastToken: Swift.Bool = false) -> SoulverCore.Token?
  final public func findParentOf(childToken: SoulverCore.Token, in tokenList: SoulverCore.TokenList, inRange limitToRange: Swift.ClosedRange<Swift.Int>? = nil) -> SoulverCore.Token?
}
public typealias TokenListEnumerationBlock = (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?) -> Swift.Void
public typealias TokenListStoppableEnumerationBlock = (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?, inout Swift.Bool) -> Swift.Void
public typealias TokenListLeftAndRightEnumerationBlock = (SoulverCore.Token, SoulverCore.Token?, SoulverCore.Token?, SoulverCore.TokenList) -> Swift.Void
public typealias TokenListTestBlock = (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?) -> Swift.Bool
extension SoulverCore.TokenList {
  final public func enumerateSublists(reversed: Swift.Bool, includeSelf: Swift.Bool, enumerationBlock: (_ subList: SoulverCore.TokenList, _ parent: SoulverCore.Token?) -> Swift.Void)
  final public func enumerateAllTokensOfType(_ type: SoulverCore.TokenType, reversed: Swift.Bool = true, enumerationBlock: (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?) -> Swift.Void)
  final public func enumerateAllTokens(reversed: Swift.Bool = true, enumerationBlock: (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?) -> Swift.Void)
  final public func enumerateAllTokensOfType(_ type: SoulverCore.TokenType, reversed: Swift.Bool, ignoreWhitespace: Swift.Bool, ensureBothSides: Swift.Bool, enumerationBlock: (SoulverCore.Token, SoulverCore.Token?, SoulverCore.Token?, SoulverCore.TokenList) -> Swift.Void)
  final public func enumerateTokens(reversed: Swift.Bool, enumerationBlock: (_ token: SoulverCore.Token, _ stop: inout Swift.Bool) -> Swift.Void)
  final public func enumerateTokensOfType(_ type: SoulverCore.TokenType, reversed: Swift.Bool, enumerationBlock: (_ token: SoulverCore.Token, _ stop: inout Swift.Bool) -> Swift.Void)
  final public func enumerateTokensOfTypes(_ types: SoulverCore.TokenTypeSet, reversed: Swift.Bool, enumerationBlock: (_ token: SoulverCore.Token, _ stop: inout Swift.Bool) -> Swift.Void)
}
extension SoulverCore.TokenList {
  final public func containsToken(token: SoulverCore.Token) -> Swift.Bool
  final public func scanForTokenWithTypes(_ tokenTypes: SoulverCore.TokenTypeSet, ignoreParentsWithTypes parentTypes: SoulverCore.TokenTypeSet? = nil) -> Swift.Bool
}
extension SoulverCore.TokenList {
  final public func typePrecheck(_ type: SoulverCore.TokenType) -> Swift.Bool
  final public func typesPrecheck(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
}
extension SoulverCore.TokenList {
  public static var EmptyList: SoulverCore.TokenList
}
@_hasMissingDesignatedInitializers public class LineCollectionTrimmer {
  public class func trimmingTokensOfTypes(_ tokenTypeSet: SoulverCore.TokenTypeSet, from lineCollection: SoulverCore.LineCollection) -> SoulverCore.LineCollection
  @objc deinit
}
extension Swift.String {
  public func find<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current) -> T.DataType? where T : SoulverCore.DataFromTokenParser
  public func find<T, U>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, locale: Foundation.Locale = .current) -> (T.DataType, U.DataType)? where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser
  public func find<T, U, Y>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<Y>, locale: Foundation.Locale = .current) -> (T.DataType, U.DataType, Y.DataType)? where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, Y : SoulverCore.DataFromTokenParser
  public func find<T, U, V, W>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<V>, _ entity4: SoulverCore.DataPoint<W>, locale: Foundation.Locale = .current) -> (T.DataType, U.DataType, V.DataType, W.DataType)? where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, V : SoulverCore.DataFromTokenParser, W : SoulverCore.DataFromTokenParser
  public func find<T, U, V, W, X>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<V>, _ entity4: SoulverCore.DataPoint<W>, _ entity5: SoulverCore.DataPoint<X>, locale: Foundation.Locale = .current) -> (T.DataType, U.DataType, V.DataType, W.DataType, X.DataType)? where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, V : SoulverCore.DataFromTokenParser, W : SoulverCore.DataFromTokenParser, X : SoulverCore.DataFromTokenParser
  public func find<T, U, V, W, X, Y>(_ entity1: SoulverCore.DataPoint<T>, _ entity2: SoulverCore.DataPoint<U>, _ entity3: SoulverCore.DataPoint<V>, _ entity4: SoulverCore.DataPoint<W>, _ entity5: SoulverCore.DataPoint<X>, _ entity6: SoulverCore.DataPoint<Y>, locale: Foundation.Locale = .current) -> (T.DataType, U.DataType, V.DataType, W.DataType, X.DataType, Y.DataType)? where T : SoulverCore.DataFromTokenParser, U : SoulverCore.DataFromTokenParser, V : SoulverCore.DataFromTokenParser, W : SoulverCore.DataFromTokenParser, X : SoulverCore.DataFromTokenParser, Y : SoulverCore.DataFromTokenParser
  public func replacingAll<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current, replacement: ((T.DataType) -> Swift.String?)) -> Swift.String where T : SoulverCore.DataFromTokenParser
  public func replacingFirst<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current, replacement: ((T.DataType) -> Swift.String?)) -> Swift.String where T : SoulverCore.DataFromTokenParser
}
public protocol DataFromTokenParser {
  associatedtype DataType
  func parseDataFrom(token: SoulverCore.Token) -> Self.DataType?
}
public struct DataPoint<T> where T : SoulverCore.DataFromTokenParser {
  public init(parser: T)
}
public struct CustomFunctionParameter {
  public let dynamicVariable: SoulverCore.DynamicVariable
  public let matchedToken: SoulverCore.Token
}
public class CustomFunctionDefinitionUtility {
  public init(customization: SoulverCore.EngineCustomization)
  public func parametersIn(customFunctionDefinition: SoulverCore.RawExpression) -> [SoulverCore.CustomFunctionParameter]?
  public func prototypeExpressionFrom(customFunctionDefinition: SoulverCore.RawExpression) -> SoulverCore.PrototypeExpression?
  public func customFunctionFrom(customFunctionDefinition: SoulverCore.RawExpression, implementationBody: SoulverCore.LineSheet) -> SoulverCore.CustomFunction?
  @objc deinit
}
public enum UnitMeasurementSystem : Swift.String, Swift.RawRepresentable, Swift.Equatable {
  case customaryUS
  case imperial
  case metric
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct Fraction : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public let unitValue: SoulverCore.SCUnit?
  public static func == (a: SoulverCore.Fraction, b: SoulverCore.Fraction) -> Swift.Bool
}
extension SoulverCore.PrototypeExpressionMatchType : Swift.Equatable {}
extension SoulverCore.PrototypeExpressionMatchType : Swift.Hashable {}
extension SoulverCore.FunctionIdentifier : Swift.Equatable {}
extension SoulverCore.FunctionIdentifier : Swift.Hashable {}
extension SoulverCore.DatestampType : Swift.Equatable {}
extension SoulverCore.DatestampType : Swift.Hashable {}
extension SoulverCore.ApparentLineType : Swift.Equatable {}
extension SoulverCore.ApparentLineType : Swift.Hashable {}
extension SoulverCore.LineCalculationBehaviour : Swift.Equatable {}
extension SoulverCore.LineCalculationBehaviour : Swift.Hashable {}
extension SoulverCore.LineCalculationBehaviour : Swift.RawRepresentable {}
extension SoulverCore.LineExpressionAlignment : Swift.Equatable {}
extension SoulverCore.LineExpressionAlignment : Swift.Hashable {}
extension SoulverCore.LineExpressionAlignment : Swift.RawRepresentable {}
extension SoulverCore.LineHighlightColor : Swift.Equatable {}
extension SoulverCore.LineHighlightColor : Swift.Hashable {}
extension SoulverCore.StatisticType : Swift.Equatable {}
extension SoulverCore.StatisticType : Swift.Hashable {}
extension SoulverCore.TokenType : Swift.Equatable {}
extension SoulverCore.TokenType : Swift.Hashable {}
extension SoulverCore.TokenSubType : Swift.Equatable {}
extension SoulverCore.TokenSubType : Swift.Hashable {}
extension SoulverCore.EvaluationError : Swift.Equatable {}
extension SoulverCore.EvaluationError : Swift.Hashable {}
extension SoulverCore.LineStyle : Swift.Equatable {}
extension SoulverCore.LineStyle : Swift.Hashable {}
extension SoulverCore.LineStyle : Swift.RawRepresentable {}
extension SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy : Swift.Equatable {}
extension SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy : Swift.Hashable {}
extension SoulverCore.LineCollectionEnumerator.ResultFormatting : Swift.Equatable {}
extension SoulverCore.LineCollectionEnumerator.ResultFormatting : Swift.Hashable {}
extension SoulverCore.UnitType : Swift.Equatable {}
extension SoulverCore.UnitType : Swift.Hashable {}
extension SoulverCore.UnitType : Swift.RawRepresentable {}
extension SoulverCore.UnitIdentifier : Swift.Equatable {}
extension SoulverCore.UnitIdentifier : Swift.Hashable {}
extension SoulverCore.SIThreshold : Swift.Equatable {}
extension SoulverCore.SIThreshold : Swift.Hashable {}
extension SoulverCore.SIThreshold : Swift.RawRepresentable {}
extension SoulverCore.DatespanType : Swift.Equatable {}
extension SoulverCore.DatespanType : Swift.Hashable {}
extension SoulverCore.DatespanSubtype : Swift.Equatable {}
extension SoulverCore.DatespanSubtype : Swift.Hashable {}
extension SoulverCore.DynamicVariable.DynamicVariableType : Swift.Equatable {}
extension SoulverCore.DynamicVariable.DynamicVariableType : Swift.Hashable {}
extension SoulverCore.AsynchronousOperation.State : Swift.Equatable {}
extension SoulverCore.AsynchronousOperation.State : Swift.Hashable {}
extension SoulverCore.AsynchronousOperation.State : Swift.RawRepresentable {}
extension SoulverCore.VariableType : Swift.Equatable {}
extension SoulverCore.VariableType : Swift.Hashable {}
extension SoulverCore.UnitSymbolReplacementPosition : Swift.Equatable {}
extension SoulverCore.UnitSymbolReplacementPosition : Swift.Hashable {}
extension SoulverCore.NotationPreferences.NotationStyle : Swift.Equatable {}
extension SoulverCore.NotationPreferences.NotationStyle : Swift.Hashable {}
extension SoulverCore.UnitMeasurementSystem : Swift.Hashable {}
