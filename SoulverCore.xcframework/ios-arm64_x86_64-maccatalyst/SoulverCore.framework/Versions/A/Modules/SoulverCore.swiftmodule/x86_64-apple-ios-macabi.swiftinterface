// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target x86_64-apple-ios13.6-macabi -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Osize -module-name SoulverCore
import Foundation
@_exported import SoulverCore
import Swift
public class VariableList : Swift.CustomDebugStringConvertible, Swift.Equatable, Swift.Hashable {
  public init()
  convenience public init(variableList: SoulverCore.VariableList)
  convenience public init(variables: [SoulverCore.Variable])
  public func provideDefinitionsForValuesWith(definitionBlock: (SoulverCore.RawExpression) -> SoulverCore.CalculationResult)
  public func allVariables() -> [SoulverCore.Variable]
  public func variablesExludingLineReferences() -> [SoulverCore.Variable]
  public func singleWordVariables() -> [SoulverCore.Variable]
  public func multiWordVariables(reverseSortByLength: Swift.Bool) -> [SoulverCore.Variable]
  public func setVariable(_ variable: SoulverCore.Variable)
  public func setVariables(_ variables: [SoulverCore.Variable])
  public func clearVariable(withName name: Swift.String)
  public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: SoulverCore.VariableList, rhs: SoulverCore.VariableList) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public struct Substance : Swift.Equatable {
  public let name: Swift.String
  public let value: Foundation.Decimal
  public var rateValue: SoulverCore.UnitRate {
    get
  }
  public static func == (a: SoulverCore.Substance, b: SoulverCore.Substance) -> Swift.Bool
}
public enum DatespanType {
  case season
  case quarter
  public static func == (a: SoulverCore.DatespanType, b: SoulverCore.DatespanType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum DatespanSubtype {
  case summer
  case autumn
  case winter
  case spring
  case firstQuarter
  case secondQuarter
  case thirdQuarter
  case fourthQuarter
  public static func == (a: SoulverCore.DatespanSubtype, b: SoulverCore.DatespanSubtype) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct Datespan : Swift.Equatable {
  public static func == (a: SoulverCore.Datespan, b: SoulverCore.Datespan) -> Swift.Bool
}
public struct CalculationResult : Swift.Equatable {
  public init(evaluationResult: SoulverCore.EvaluationResult, stringValue: Swift.String)
  public let evaluationResult: SoulverCore.EvaluationResult
  public let stringValue: Swift.String
  public static func == (a: SoulverCore.CalculationResult, b: SoulverCore.CalculationResult) -> Swift.Bool
}
extension CalculationResult {
  public var isEmptyResult: Swift.Bool {
    get
  }
  public var isPendingResult: Swift.Bool {
    get
  }
  public var isFailedResult: Swift.Bool {
    get
  }
}
public let EmptyResult: SoulverCore.CalculationResult
public let PendingResult: SoulverCore.CalculationResult
public let FailedResult: SoulverCore.CalculationResult
public typealias UID = Swift.String
public struct LineReference : Swift.Equatable, Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible {
  public let UID: SoulverCore.UID
  public init(UID: SoulverCore.UID)
  public var description: Swift.String {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public static func == (a: SoulverCore.LineReference, b: SoulverCore.LineReference) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol Evaluator {
  func evaluate(_ tokenList: SoulverCore.TokenList) -> SoulverCore.EvaluationResult
}
public struct Laptime : Swift.Equatable {
  public static func == (a: SoulverCore.Laptime, b: SoulverCore.Laptime) -> Swift.Bool
}
public struct WhileEscape {
  public init(maximumCycles: Swift.Int)
  public mutating func increment()
  public var shouldBreak: Swift.Bool {
    get
  }
}
public enum UnitType : Swift.String, Swift.CaseIterable, Swift.Codable {
  case length
  case mass
  case duration
  case currency
  case volume
  case speed
  case acceleration
  case temperature
  case concentrationMass
  case dispersion
  case dataStorage
  case dataTransfer
  case area
  case frequency
  case angle
  case illuminance
  case energy
  case power
  case pressure
  case electricCurrent
  case electricCharge
  case electricPotential
  case electricResistance
  case other
  public var label: Swift.String {
    get
  }
  public var baseUnitIdentifier: SoulverCore.UnitIdentifier {
    get
  }
  public var associatedOtherUnits: [SoulverCore.UnitIdentifier] {
    get
  }
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [SoulverCore.UnitType]
  public static var allCases: [SoulverCore.UnitType] {
    get
  }
}
public enum UnitIdentifier : Swift.String, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable {
  case metersPerSecondSquared
  case gravity
  case degrees
  case arcMinutes
  case arcSeconds
  case radians
  case gradians
  case revolutions
  case squareMegameters
  case squareKilometers
  case squareMeters
  case squareCentimeters
  case squareMillimeters
  case squareMicrometers
  case squareNanometers
  case squareInches
  case squareFeet
  case squareYards
  case squareMiles
  case acres
  case ares
  case hectares
  case gramsPerLiter
  case milligramsPerDeciliter
  case partsPerMillion
  case picoseconds
  case nanoseconds
  case microseconds
  case milliseconds
  case seconds
  case minutes
  case hours
  case days
  case weekdays
  case weeks
  case months
  case years
  case coulombs
  case megaampereHours
  case kiloampereHours
  case ampereHours
  case milliampereHours
  case microampereHours
  case megaamperes
  case kiloamperes
  case amperes
  case milliamperes
  case microamperes
  case megavolts
  case kilovolts
  case volts
  case millivolts
  case microvolts
  case megaohms
  case kiloohms
  case ohms
  case milliohms
  case microohms
  case joules
  case kilojoules
  case megajoules
  case gigajoules
  case kilocalories
  case calories
  case wattSeconds
  case wattMinutes
  case wattHours
  case kilowattHours
  case megawattHours
  case gigawattHours
  case terawattHours
  case terahertz
  case gigahertz
  case megahertz
  case kilohertz
  case hertz
  case millihertz
  case microhertz
  case nanohertz
  case megameters
  case kilometers
  case hectometers
  case decameters
  case meters
  case decimeters
  case centimeters
  case millimeters
  case micrometers
  case nanometers
  case picometers
  case inches
  case feet
  case yards
  case miles
  case scandinavianMiles
  case lightyears
  case astronomicalUnits
  case nauticalMiles
  case fathoms
  case furlongs
  case parsecs
  case lux
  case kilograms
  case grams
  case decigrams
  case centigrams
  case milligrams
  case micrograms
  case nanograms
  case picograms
  case ounces
  case pounds
  case stones
  case metricTons
  case shortTons
  case carats
  case ouncesTroy
  case slugs
  case terawatts
  case gigawatts
  case megawatts
  case kilowatts
  case watts
  case milliwatts
  case microwatts
  case nanowatts
  case picowatts
  case femtowatts
  case horsepower
  case newtonsPerMetersSquared
  case gigapascals
  case megapascals
  case kilopascals
  case hectopascals
  case inchesOfMercury
  case bars
  case millibars
  case millimetersOfMercury
  case poundsForcePerSquareInch
  case metersPerSecond
  case kilometersPerHour
  case milesPerHour
  case knots
  case kelvin
  case celsius
  case fahrenheit
  case megaliters
  case kiloliters
  case liters
  case milliliters
  case centiliters
  case deciliters
  case cubicKilometers
  case cubicMeters
  case cubicDecimeters
  case cubicCentimeters
  case cubicMillimeters
  case cubicInches
  case cubicFeet
  case cubicYards
  case cubicMiles
  case acreFeet
  case bushels
  case teaspoons
  case tablespoons
  case fluidOunces
  case cups
  case pints
  case quarts
  case gallons
  case imperialTeaspoons
  case imperialTablespoons
  case imperialFluidOunces
  case imperialPints
  case imperialQuarts
  case imperialGallons
  case metricCups
  case metricTeaspoons
  case metricTablespoons
  case metricAUTablespoons
  case bytes
  case bits
  case nibbles
  case yottabytes
  case zettabytes
  case exabytes
  case petabytes
  case terabytes
  case gigabytes
  case megabytes
  case kilobytes
  case yottabits
  case zettabits
  case exabits
  case petabits
  case terabits
  case gigabits
  case megabits
  case kilobits
  case yobibytes
  case zebibytes
  case exbibytes
  case pebibytes
  case tebibytes
  case gibibytes
  case mebibytes
  case kibibytes
  case yobibits
  case zebibits
  case exbibits
  case pebibits
  case tebibits
  case gibibits
  case mebibits
  case kibibits
  case pixel
  case em
  case point
  case bytesPerSecond
  case bitsPerSecond
  case yottabytesPerSecond
  case zettabytesPerSecond
  case exabytesPerSecond
  case petabytesPerSecond
  case terabytesPerSecond
  case gigabytesPerSecond
  case megabytesPerSecond
  case kilobytesPerSecond
  case yottabitsPerSecond
  case zettabitsPerSecond
  case exabitsPerSecond
  case petabitsPerSecond
  case terabitsPerSecond
  case gigabitsPerSecond
  case megabitsPerSecond
  case kilobitsPerSecond
  case yobibytesPerSecond
  case zebibytesPerSecond
  case exbibytesPerSecond
  case pebibytesPerSecond
  case tebibytesPerSecond
  case gibibytesPerSecond
  case mebibytesPerSecond
  case kibibytesPerSecond
  case yobibitsPerSecond
  case zebibitsPerSecond
  case exbibitsPerSecond
  case pebibitsPerSecond
  case tebibitsPerSecond
  case gibibitsPerSecond
  case mebibitsPerSecond
  case kibibitsPerSecond
  case currencyADA
  case currencyAED
  case currencyAFN
  case currencyALL
  case currencyAMD
  case currencyANG
  case currencyAOA
  case currencyARS
  case currencyAUD
  case currencyAWG
  case currencyAZN
  case currencyBAM
  case currencyBBD
  case currencyBCH
  case currencyBDT
  case currencyBGN
  case currencyBHD
  case currencyBIF
  case currencyBMD
  case currencyBNB
  case currencyBND
  case currencyBOB
  case currencyBRL
  case currencyBSD
  case currencyBSV
  case currencyBTC
  case currencyBTN
  case currencyBWP
  case currencyBYN
  case currencyBZD
  case currencyCAD
  case currencyCDF
  case currencyCHF
  case currencyCLF
  case currencyCLP
  case currencyCNY
  case currencyCOP
  case currencyCRC
  case currencyCUC
  case currencyCVE
  case currencyCZK
  case currencyDASH
  case currencyDJF
  case currencyDKK
  case currencyDOGE
  case currencyDOP
  case currencyDZD
  case currencyEGP
  case currencyEOS
  case currencyERN
  case currencyETB
  case currencyETC
  case currencyETH
  case currencyEUR
  case currencyFJD
  case currencyFKP
  case currencyGBP
  case currencyGEL
  case currencyGGP
  case currencyGHS
  case currencyGIP
  case currencyGMD
  case currencyGNF
  case currencyGTQ
  case currencyGYD
  case currencyHKD
  case currencyHNL
  case currencyHRK
  case currencyHTG
  case currencyHUF
  case currencyIDR
  case currencyILS
  case currencyIMP
  case currencyINR
  case currencyIQD
  case currencyIRR
  case currencyISK
  case currencyJEP
  case currencyJMD
  case currencyJOD
  case currencyJPY
  case currencyKES
  case currencyKGS
  case currencyKHR
  case currencyKMF
  case currencyKPW
  case currencyKRW
  case currencyKWD
  case currencyKYD
  case currencyKZT
  case currencyLAK
  case currencyLBP
  case currencyLKR
  case currencyLRD
  case currencyLSL
  case currencyLTC
  case currencyLTL
  case currencyLVL
  case currencyLYD
  case currencyMAD
  case currencyMDL
  case currencyMGA
  case currencyMKD
  case currencyMMK
  case currencyMNT
  case currencyMOP
  case currencyMRO
  case currencyMUR
  case currencyMVR
  case currencyMWK
  case currencyMXN
  case currencyMYR
  case currencyMZN
  case currencyNAD
  case currencyNEO
  case currencyNGN
  case currencyNIO
  case currencyNOK
  case currencyNPR
  case currencyNZD
  case currencyOMR
  case currencyPAB
  case currencyPEN
  case currencyPGK
  case currencyPHP
  case currencyPKR
  case currencyPLN
  case currencyPYG
  case currencyQAR
  case currencyRON
  case currencyRSD
  case currencyRUB
  case currencyRWF
  case currencySAR
  case currencySBD
  case currencySCR
  case currencySDG
  case currencySEK
  case currencySGD
  case currencySHP
  case currencySLL
  case currencySOS
  case currencySRD
  case currencySTD
  case currencySVC
  case currencySYP
  case currencySZL
  case currencyTHB
  case currencyTJS
  case currencyTMT
  case currencyTND
  case currencyTOP
  case currencyTRX
  case currencyTRY
  case currencyTTD
  case currencyTWD
  case currencyTZS
  case currencyUAH
  case currencyUGX
  case currencyUSD
  case currencyUYU
  case currencyUZS
  case currencyVEF
  case currencyVND
  case currencyVUV
  case currencyWST
  case currencyXAF
  case currencyXAG
  case currencyXAU
  case currencyXCD
  case currencyXDR
  case currencyXLM
  case currencyXMR
  case currencyXOF
  case currencyXPF
  case currencyXRP
  case currencyYER
  case currencyZAR
  case currencyZMK
  case currencyZMW
  case currencyZWL
  case currencySatoshi
  case currencyDollarCents
  case currencyBritishPence
  case currencyEuroCents
  case undefined
  public var unit: SoulverCore.SCUnit {
    get
  }
  public var unitType: SoulverCore.UnitType {
    get
  }
  public var motherUnitIdentifier: SoulverCore.UnitIdentifier {
    get
  }
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [SoulverCore.UnitIdentifier]
  public static var allCases: [SoulverCore.UnitIdentifier] {
    get
  }
}
extension Int {
  public func compare(_ other: Swift.Int) -> Foundation.ComparisonResult
}
public struct EngineCustomization : Swift.Equatable, Swift.Hashable {
  public let locale: Foundation.Locale
  public let calendar: Foundation.Calendar
  public var timeZone: Foundation.TimeZone {
    get
  }
  public var customVariables: [SoulverCore.Variable] {
    get
    set
  }
  public var customUnits: [SoulverCore.CustomUnit] {
    get
    set
  }
  public var customSymbols: [SoulverCore.UnitSymbolReplacement] {
    get
    set
  }
  public var customPlaces: [SoulverCore.Place] {
    get
    set
  }
  public var customFunctions: [SoulverCore.CustomFunction] {
    get
    set
  }
  public var dynamicVariables: [SoulverCore.DynamicVariable] {
    get
    set
  }
  public var currencyUnits: [SoulverCore.UnitDescription] {
    get
    set
  }
  public var holidays: [SoulverCore.Holiday]
  public var unitSystem: SoulverCore.UnitMeasurementSystem
  public var featureFlags: SoulverCore.EngineFeatureFlags
  public init(locale: Foundation.Locale, calendar: Foundation.Calendar? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: SoulverCore.EngineCustomization, rhs: SoulverCore.EngineCustomization) -> Swift.Bool
  public static var standard: SoulverCore.EngineCustomization {
    get
  }
  public func convertTo(locale: Foundation.Locale) -> SoulverCore.EngineCustomization
  public var hashValue: Swift.Int {
    get
  }
}
extension EngineCustomization {
  public static func engineWithLocale(locale: Foundation.Locale) -> SoulverCore.EngineCustomization
  public func isOperator(text: Swift.String) -> Swift.Bool
  public func longFormNameFor(unit: SoulverCore.SCUnit) -> Swift.String?
}
public struct Percentage : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public static func == (a: SoulverCore.Percentage, b: SoulverCore.Percentage) -> Swift.Bool
}
public struct UnitExpression {
  public let value: Foundation.Decimal
  public let unit: SoulverCore.SCUnit
}
extension UnitExpression : Swift.Comparable {
  public static func == (lhs: SoulverCore.UnitExpression, rhs: SoulverCore.UnitExpression) -> Swift.Bool
  public static func < (lhs: SoulverCore.UnitExpression, rhs: SoulverCore.UnitExpression) -> Swift.Bool
}
extension UnitExpression : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SCUnit {
  public var prefersZeroDP: Swift.Bool {
    get
  }
}
public typealias RawExpression = Swift.String
extension Locale {
  public static let chineseLocalePrefix: Swift.String
  public var isChinese: Swift.Bool {
    get
  }
  public var isTraditionalChinese: Swift.Bool {
    get
  }
  public var isSimplifiedChinese: Swift.Bool {
    get
  }
  public var isAussieSpeaking: Swift.Bool {
    get
  }
  public var isRussian: Swift.Bool {
    get
  }
  public var isEngish: Swift.Bool {
    get
  }
  public var isGerman: Swift.Bool {
    get
  }
}
public struct Place : Swift.Hashable, Swift.Equatable {
  public enum PlaceType : Swift.Equatable, Swift.Hashable {
    case country(country: SoulverCore.Country)
    case city(city: SoulverCore.City)
    case airport(airport: SoulverCore.Airport)
    case timeZoneAbbreviation
    case unspecified
    public static func == (a: SoulverCore.Place.PlaceType, b: SoulverCore.Place.PlaceType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(name: Swift.String, aliases: [Swift.String]?, timeZone: Foundation.TimeZone, type: SoulverCore.Place.PlaceType = .unspecified)
  public let name: Swift.String
  public let aliases: [Swift.String]?
  public let timeZone: Foundation.TimeZone
  public let type: SoulverCore.Place.PlaceType
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.Place, b: SoulverCore.Place) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class LineCollectionCompletions {
  public class func completionsFor(textFragment: Swift.String, charIndex: Swift.Int, onLineAtIndex lineIndex: SoulverCore.LineIndex, in lineCollection: SoulverCore.LineCollection) -> [Swift.String]
  @objc deinit
}
public class Line : Swift.Codable {
  public var expression: Swift.String
  public var behaviour: SoulverCore.LineCalculationBehaviour
  public var skipStatistics: Swift.Bool
  public var lineReference: SoulverCore.LineReference?
  public var formattingPreferences: SoulverCore.FormattingPreferences?
  public var tags: [Swift.String]
  public var result: SoulverCore.CalculationResult?
  public var parsedExpression: SoulverCore.TokenList?
  public var apparentLineType: SoulverCore.ApparentLineType?
  public var lineIndex: SoulverCore.LineIndex?
  public var explicitDependencies: Foundation.IndexSet?
  public var variableEnvironment: SoulverCore.VariableList?
  public var rawResult: Swift.String {
    get
  }
  public var formattedResult: Swift.String {
    get
  }
  convenience public init(_ expression: SoulverCore.RawExpression)
  public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
extension Line {
  public var isSubtotal: Swift.Bool {
    get
  }
  public var isHeading: Swift.Bool {
    get
  }
}
extension Line {
  public var declaredVariable: SoulverCore.Variable? {
    get
  }
  public func referencesInExpressionTo(variable: SoulverCore.Variable) -> [SoulverCore.Token]
  public var indexesReferencedInExpression: Foundation.IndexSet {
    get
  }
}
extension Line : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: SoulverCore.Line, rhs: SoulverCore.Line) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static var EmptyLine: SoulverCore.Line {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Line : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum ApparentLineType {
  case regular
  case comment
  case variableDeclaration
  public static func == (a: SoulverCore.ApparentLineType, b: SoulverCore.ApparentLineType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum LineCalculationBehaviour : Swift.String, Swift.Codable {
  case evaluatesExpression
  case sumsLinesAbove
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension NSNotification.Name {
  public static let currenciesUpdateSucceeded: Foundation.Notification.Name
  public static let currenciesUpdateFailed: Foundation.Notification.Name
  public static let currenciesUpdateStarted: Foundation.Notification.Name
}
public enum CurrencySet : Swift.String {
  case popular
  case realWorld
  case realWorldPlusCrypto
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct CurrencySourceCredentials {
  public init(currencyLayerKey: Swift.String?, nomicsKey: Swift.String?)
}
@_hasMissingDesignatedInitializers public class CurrencyList {
  public static let shared: SoulverCore.CurrencyList
  public var rateRefreshingCredentials: SoulverCore.CurrencySourceCredentials
  public var defaultCurrencySet: SoulverCore.CurrencySet {
    get
    set
  }
  public func refreshRates(completionHandler: ((Swift.Bool) -> Swift.Void)? = nil)
  public func saveCurrenciesTo(url: Foundation.URL)
  public func loadCurrenciesFrom(url: Foundation.URL) throws
  @objc deinit
}
public typealias VariableName = Swift.String
public typealias VariableValue = Swift.String
public enum VariableType : Swift.String, Swift.RawRepresentable, Swift.Codable {
  case undefined
  case local
  case global
  case lineReference
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct Variable : Swift.Codable {
  public let name: SoulverCore.VariableName
  public let value: SoulverCore.VariableValue?
  public init(name: SoulverCore.VariableName, value: SoulverCore.VariableValue?, type: SoulverCore.VariableType = .undefined)
  public var declaringLineIndex: SoulverCore.LineIndex?
  public var definition: SoulverCore.EvaluationResult?
  public var type: SoulverCore.VariableType
  public var isPhrase: Swift.Bool?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Variable : Swift.Hashable, Swift.Equatable {
  public static func == (lhs: SoulverCore.Variable, rhs: SoulverCore.Variable) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias Scalar = Swift.String
public struct UnitRate {
  public let value: Foundation.Decimal
  public let ofUnit: SoulverCore.SCUnit?
  public let perUnit: SoulverCore.SCUnit
}
extension UnitRate : Swift.Comparable {
  public static func < (lhs: SoulverCore.UnitRate, rhs: SoulverCore.UnitRate) -> Swift.Bool
  public static func == (a: SoulverCore.UnitRate, b: SoulverCore.UnitRate) -> Swift.Bool
}
extension UnitRate : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension UnitExpression : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct LineCollectionArchive : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class LineCollectionArchiver {
  public class func encode(lineCollection: SoulverCore.LineCollection) -> Foundation.Data?
  public class func decode(encodedLineSheet: Foundation.Data, withCustomization customization: SoulverCore.EngineCustomization, preferredLocale locale: Foundation.Locale, defaultLineFormatting: SoulverCore.FormattingPreferences?, customEvaluator: SoulverCore.Evaluator? = nil) throws -> SoulverCore.LineCollection
  public class func archiveFor(lineCollection: SoulverCore.LineCollection) -> SoulverCore.LineCollectionArchive
  public class func lineCollectionFrom(archive: SoulverCore.LineCollectionArchive, withCustomization customization: SoulverCore.EngineCustomization, preferredLocale locale: Foundation.Locale) -> SoulverCore.LineCollection
  @objc deinit
}
public protocol RoutineOwner : AnyObject {
  func routineCompleted(routine: SoulverCore.Routine)
}
public protocol Routine : AnyObject {
  var routineOwner: SoulverCore.RoutineOwner? { get set }
  func go()
  func goWithCompletionBlock(completion: @escaping (() -> Swift.Void))
}
extension Routine {
  public func goWithCompletionBlock(completion: @escaping (() -> Swift.Void))
}
@_hasMissingDesignatedInitializers public class StaticResouces {
  public static var localizedCountries: [SoulverCore.Country] {
    get
  }
  public static var localizedCities: [SoulverCore.City] {
    get
  }
  @objc deinit
}
public typealias DynamicVariableDefinitonBlock = (SoulverCore.VariableList) -> SoulverCore.CalculationResult
public struct DynamicVariable : Swift.Hashable, Swift.Equatable {
  public enum DynamicVariableType {
    case undefined
    case distantValue
    case subsheet
    public static func == (a: SoulverCore.DynamicVariable.DynamicVariableType, b: SoulverCore.DynamicVariable.DynamicVariableType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(symbol: Swift.String, type: SoulverCore.DynamicVariable.DynamicVariableType = .undefined, handler: @escaping SoulverCore.DynamicVariableDefinitonBlock)
  public let type: SoulverCore.DynamicVariable.DynamicVariableType
  public let name: Swift.String
  public let handler: SoulverCore.DynamicVariableDefinitonBlock
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: SoulverCore.DynamicVariable, rhs: SoulverCore.DynamicVariable) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public class EvaluationResultFormatter {
  public init(customization: SoulverCore.EngineCustomization, formattingPreferences: SoulverCore.FormattingPreferences?)
  public func format(result: SoulverCore.EvaluationResult) -> SoulverCore.CalculationResult
  @objc deinit
}
public typealias TokenIndex = Swift.Int
public struct TokenIndexPath : Swift.Equatable {
  public let tokenIndex: SoulverCore.TokenIndex
  public let lineIndex: SoulverCore.LineIndex
  public init(tokenIndex: SoulverCore.TokenIndex, lineIndex: SoulverCore.LineIndex)
  public static func == (a: SoulverCore.TokenIndexPath, b: SoulverCore.TokenIndexPath) -> Swift.Bool
}
extension NumberFormatter {
  open func string(from number: Foundation.Decimal) -> Swift.String?
}
public enum DatestampType {
  case clockTime
  case nakedDayOfMonth
  case nakedMonth
  case nakedYear
  case dayAndMonth
  case monthAndYear
  case dayMonthYear
  case weekDay
  case now
  case today
  case tomorrow
  case yesterday
  case nextWeek
  case nextMonth
  case nextYear
  case lastWeek
  case lastYear
  case lastMonth
  case quarter
  case unspecified
  public static func == (a: SoulverCore.DatestampType, b: SoulverCore.DatestampType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct Datestamp : Swift.Equatable {
  public init(date: Foundation.Date, type: SoulverCore.DatestampType, timezone: Foundation.TimeZone, hasExplicitTimeComponent: Swift.Bool, hasExplicitTimeZone: Swift.Bool, isAmbiguous: Swift.Bool = false)
  public let date: Foundation.Date
  public var type: SoulverCore.DatestampType
  public var timezone: Foundation.TimeZone
  public let hasExplicitTimeComponent: Swift.Bool
  public let hasExplicitTimeZone: Swift.Bool
  public let isAmbiguous: Swift.Bool
  public static func == (a: SoulverCore.Datestamp, b: SoulverCore.Datestamp) -> Swift.Bool
}
public struct ExportOptions {
  public var plainTextSeparator: Swift.String
  public var useUnformattedResults: Swift.Bool
  public var substituteLineReferences: Swift.Bool
  public var includeAnswers: Swift.Bool
  public init()
}
@_hasMissingDesignatedInitializers public class LineCollectionExporter {
  public class func jsonDataFor(lineCollection: SoulverCore.LineCollection) -> Foundation.Data?
  public class func csvDataFor(lineCollection: SoulverCore.LineCollection, options: SoulverCore.ExportOptions) -> Foundation.Data?
  public class func textDataFor(lineCollection: SoulverCore.LineCollection, options: SoulverCore.ExportOptions) -> Foundation.Data?
  public class func textFor(lineCollection: SoulverCore.LineCollection, options: SoulverCore.ExportOptions) -> Swift.String
  @objc deinit
}
public class Calculator {
  public var formattingPreferences: SoulverCore.FormattingPreferences?
  public var customization: SoulverCore.EngineCustomization {
    get
  }
  public var customFunctionEvaluator: SoulverCore.CustomFunctionEvaluator?
  public init(customization: SoulverCore.EngineCustomization)
  public func calculate(_ expression: Swift.String, with variableList: SoulverCore.VariableList? = nil) -> SoulverCore.CalculationResult
  public func calculate(_ expression: Swift.String, with variableList: SoulverCore.VariableList? = nil, completionHandler: @escaping ((SoulverCore.CalculationResult) -> Swift.Void))
  @objc deinit
}
public protocol CustomFunctionEvaluator {
  func evaluate(customFunction: SoulverCore.CustomFunction, with parameters: [SoulverCore.EvaluationResult]) -> SoulverCore.EvaluationResult
}
extension Calculator {
  public func dateFor(_ expression: Swift.String, with variableList: SoulverCore.VariableList? = nil) -> (date: Foundation.Date, result: SoulverCore.CalculationResult)?
}
extension IndexSet {
  public func isJust(_ integer: Swift.Int) -> Swift.Bool
  public var onlyFirst: Foundation.IndexSet {
    get
  }
  public var removingFirstIndex: Foundation.IndexSet {
    get
  }
  public var smartDescription: Swift.String {
    get
  }
  public var secondLastIndex: Swift.Int? {
    get
  }
}
public typealias CustomFunctionHandler = ([SoulverCore.EvaluationResult]) -> SoulverCore.EvaluationResult
public typealias PrototypePlaceholder = Swift.String
public class CustomType : Swift.Hashable, Swift.Equatable {
  public init(prototypePlaceholder: SoulverCore.PrototypePlaceholder, symbols: [Swift.String], associatedObject: Any?)
  final public let prototypePlaceholder: SoulverCore.PrototypePlaceholder
  final public let symbols: [Swift.String]
  final public let associatedObject: Any?
  public static func == (lhs: SoulverCore.CustomType, rhs: SoulverCore.CustomType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public struct CustomFunction : Swift.Hashable, Swift.Equatable {
  public init(prototypeExpression: Swift.String, handler: @escaping SoulverCore.CustomFunctionHandler)
  public var backgroundHandler: SoulverCore.CustomFunctionHandler?
  public var customTypes: [SoulverCore.CustomType]?
  public static func == (lhs: SoulverCore.CustomFunction, rhs: SoulverCore.CustomFunction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Airport : Swift.Codable, Swift.Hashable, Swift.Equatable {
  public static func == (a: SoulverCore.Airport, b: SoulverCore.Airport) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct Token : Swift.Equatable, Swift.Hashable, Swift.Comparable {
  public static func == (lhs: SoulverCore.Token, rhs: SoulverCore.Token) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func < (lhs: SoulverCore.Token, rhs: SoulverCore.Token) -> Swift.Bool
  public let type: SoulverCore.TokenType
  public let subType: SoulverCore.TokenSubType
  public var stringValue: Swift.String
  public var range: Foundation.NSRange
  public var subtokens: SoulverCore.TokenList?
  public var metadata: SoulverCore.TokenMetadata?
  public var hashValue: Swift.Int {
    get
  }
}
extension Token : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension TokenList : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: SoulverCore.TokenList, rhs: SoulverCore.TokenList) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TokenList {
  public var tokens: [SoulverCore.Token]
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var flattenedTokens: [SoulverCore.Token] {
    get
  }
  public subscript(index: Swift.Int) -> SoulverCore.Token {
    get
    set(newValue)
  }
  public func tokensOfType(_ tokenType: SoulverCore.TokenType) -> [SoulverCore.Token]
  public func allTokensOfType(_ tokenType: SoulverCore.TokenType) -> [SoulverCore.Token]
  public func allTypesHaveBeenPresentIn(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  public func onlyTypesHaveBeenPresentIn(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  public func anyTypesHaveBeenPresentIn(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  public func tokenBefore(_ token: SoulverCore.Token, mustBe type: SoulverCore.TokenType, ignoreWhitespace: Swift.Bool = true, ignoreTypes: SoulverCore.TokenTypeSet? = nil) -> SoulverCore.Token?
  public func tokenAfter(_ token: SoulverCore.Token, mustBe type: SoulverCore.TokenType, ignoreWhitespace: Swift.Bool = true, ignoreTypes: SoulverCore.TokenTypeSet? = nil) -> SoulverCore.Token?
  public func tokenAfter(_ token: SoulverCore.Token, mustBeIn types: SoulverCore.TokenTypeSet, ignoreWhitespace: Swift.Bool = true, ignoreTypes: SoulverCore.TokenTypeSet? = nil) -> SoulverCore.Token?
  public func tokenBefore(_ token: SoulverCore.Token, mustBeIn types: SoulverCore.TokenTypeSet, ignoreWhitespace: Swift.Bool = true, ignoreTypes: SoulverCore.TokenTypeSet? = nil) -> SoulverCore.Token?
  @objc deinit
}
extension TokenList {
  public var rebuiltExpression: SoulverCore.RawExpression {
    get
  }
}
extension TokenList : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension TokenList {
  public func tokenFor(tokenIndex: SoulverCore.TokenIndex) -> SoulverCore.Token?
  public func tokenIndexFor(token: SoulverCore.Token) -> SoulverCore.TokenIndex?
  public func tokenFor(characterIndex: Swift.Int, ignoreWhitespace: Swift.Bool = true) -> SoulverCore.Token?
  public func findParentOf(childToken: SoulverCore.Token, in tokenList: SoulverCore.TokenList, inRange limitToRange: Swift.ClosedRange<Swift.Int>? = nil) -> SoulverCore.Token?
}
public typealias TokenListEnumerationBlock = (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?) -> Swift.Void
public typealias TokenListStoppableEnumerationBlock = (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?, inout Swift.Bool) -> Swift.Void
public typealias TokenListLeftAndRightEnumerationBlock = (SoulverCore.Token, SoulverCore.Token?, SoulverCore.Token?, SoulverCore.TokenList) -> Swift.Void
public typealias TokenListTestBlock = (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?) -> Swift.Bool
extension TokenList {
  public func enumerateSublists(reversed: Swift.Bool, includeSelf: Swift.Bool, enumerationBlock: (SoulverCore.TokenList, SoulverCore.Token?) -> Swift.Void)
  public func enumerateAllTokensOfType(_ type: SoulverCore.TokenType, reversed: Swift.Bool = true, enumerationBlock: (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?) -> Swift.Void)
  public func enumerateAllTokens(reversed: Swift.Bool = true, enumerationBlock: (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?) -> Swift.Void)
  public func enumerateAllTokensOfType(_ type: SoulverCore.TokenType, reversed: Swift.Bool, ignoreWhitespace: Swift.Bool, ensureBothSides: Swift.Bool, enumerationBlock: (SoulverCore.Token, SoulverCore.Token?, SoulverCore.Token?, SoulverCore.TokenList) -> Swift.Void)
  public func enumerateTokens(reversed: Swift.Bool, enumerationBlock: (SoulverCore.Token, inout Swift.Bool) -> Swift.Void)
  public func enumerateTokensOfType(_ type: SoulverCore.TokenType, reversed: Swift.Bool, enumerationBlock: (SoulverCore.Token, inout Swift.Bool) -> Swift.Void)
  public func enumerateTokensOfTypes(_ types: SoulverCore.TokenTypeSet, reversed: Swift.Bool, enumerationBlock: (SoulverCore.Token, inout Swift.Bool) -> Swift.Void)
}
extension TokenList {
  public func containsToken(token: SoulverCore.Token) -> Swift.Bool
  public func scanForTokenWithTypes(_ tokenTypes: SoulverCore.TokenTypeSet, ignoreParentsWithTypes parentTypes: SoulverCore.TokenTypeSet? = nil) -> Swift.Bool
}
extension TokenList {
  public func typePrecheck(_ type: SoulverCore.TokenType) -> Swift.Bool
  public func typesPrecheck(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
}
extension TokenList {
  public static var EmptyList: SoulverCore.TokenList
}
extension String {
  public func removingThousandsSeparators(locale: Foundation.Locale) -> Swift.String
  public func wrappedIn(_ character: Swift.String) -> Swift.String
  public func bracketed() -> Swift.String
  public func invertedCommad() -> Swift.String
  public func spaced() -> Swift.String
  public static var standardEasternEuropeanThousandsSeparator: Swift.String
  public static var standardWhitespace: Swift.String
  public static var nonBreakingSpace: Swift.String
  public static let standardDecimalPoint: Swift.String
  public static let newlineSymbol: Swift.String
  public var isNewline: Swift.Bool {
    get
  }
  public var isSingleWhitespace: Swift.Bool {
    get
  }
  public var isLowerecased: Swift.Bool {
    get
  }
  public var isUppercased: Swift.Bool {
    get
  }
  public var isMixedCase: Swift.Bool {
    get
  }
  public func replaceCharactersFromSet(characterSet: Foundation.CharacterSet, replacementString: Swift.String = "") -> Swift.String
  public var whitespaceStandardized: Swift.String {
    get
  }
  public var whitespaceRemoved: Swift.String {
    get
  }
  public var whitespaceTrimmed: Swift.String {
    get
  }
  public func firstWord() -> Swift.String?
}
extension String {
  public var completeStringRange: Foundation.NSRange {
    get
  }
  public var completeRange: Swift.Range<Swift.String.Index> {
    get
  }
  public var dirtyWordCount: Swift.Int {
    get
  }
  public var dirtyLineCount: Swift.Int {
    get
  }
  public var newLineCount: Swift.Int {
    get
  }
  public var isNotEmpty: Swift.Bool {
    get
  }
  public func removingPrefix(_ prefix: Swift.String) -> Swift.String
  public func removingSuffix(_ suffix: Swift.String) -> Swift.String
  public func addingPrefix(_ prefix: Swift.String) -> Swift.String
  public func addingSuffix(_ suffix: Swift.String) -> Swift.String
  public func characterBefore(_ index: Swift.String.Index) -> Swift.Character?
  public func characterAfter(_ index: Swift.String.Index) -> Swift.Character?
  public var lastCharaterIndex: Swift.String.Index? {
    get
  }
}
extension String {
  public func enumerateCharacters(invoking body: @escaping (Swift.String, inout Swift.Bool) -> Swift.Void)
  public func enumerateRangesOf(pattern: Swift.String, reverse: Swift.Bool, invoking body: @escaping (Foundation.NSRange) -> Swift.Void)
  public func enumerateParagraphs(invoking body: @escaping (Swift.String, inout Swift.Bool) -> Swift.Void)
  public var isSingleWord: Swift.Bool {
    get
  }
  public var isPhrase: Swift.Bool {
    get
  }
}
extension String {
  public func containsPattern(_ regex: Swift.String) -> Swift.Bool
  public func capturedGroups(with pattern: Foundation.NSRegularExpression) -> [Foundation.NSRange]
  public func capturedGroups(withRegex pattern: Swift.String) -> [Foundation.NSRange]
  public func erasingPattern(_ pattern: Swift.String) -> Swift.String
  public var trailingDigit: Swift.Int? {
    get
  }
}
extension String {
  public func containsCharacter(_ element: Swift.Character) -> Swift.Bool
  public func rangesOf(string: Swift.String) -> [Swift.Range<Swift.String.Index>]
  public func rangesOf(strings: [Swift.String]) -> [Swift.Range<Swift.String.Index>]
}
public enum TokenType : Swift.CaseIterable {
  case number
  case `operator`
  case percentageSymbol
  case converterSymbol
  case unit
  case bracket
  case whitespace
  case variable
  case dynamicVariable
  case equals
  case pi
  case typeName
  case conditionalKeyword
  case conjunctionWord
  case function
  case timezone
  case substance
  case comma
  case dot
  case colon
  case label
  case fraction
  case binaryNumber
  case hexadecimalNumber
  case converter
  case unixTimestamp
  case datestamp
  case iso8601
  case timespan
  case laptime
  case datespan
  case dateWord
  case dateQualifier
  case ordinalSuffix
  case relativePlaceWord
  case numberWord
  case unitExpression
  case compoundUnitExpression
  case conditionalExpression
  case percentage
  case multiplier
  case boolean
  case rate
  case functionExpression
  case wordFunction
  case variableDeclaration
  case declaredVariable
  case variableAssignmentOperator
  case subexpression
  case comment
  case wordComment
  case bracketComment
  case slashComment
  case legacyQuotationComment
  case labelExpression
  case url
  case customType
  case error
  case pending
  case failed
  case scalar
  case unidentified
  case customInternal
  case dateComponents
  case literal
  public static func == (a: SoulverCore.TokenType, b: SoulverCore.TokenType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [SoulverCore.TokenType]
  public static var allCases: [SoulverCore.TokenType] {
    get
  }
}
public enum TokenSubType {
  case additionOperator
  case subtractionOperator
  case multiplicationOperator
  case divisionOperator
  case reverseDivisionOperator
  case reverseSubtractionOperator
  case powerOperator
  case modOperator
  case lesserOf
  case greaterOf
  case greaterThan
  case greaterThanOrEqualTo
  case lessThan
  case lessThanOrEqualTo
  case equalTo
  case notEqualTo
  case `false`
  case `true`
  case openBracket
  case closeBracket
  case numberConverter
  case fractionConverter
  case multiplierConveter
  case binaryConverter
  case hexadecimalConverter
  case percentageConverter
  case percentageApplier
  case unitConverter
  case unitExpressionConverter
  case rateConverter
  case dateConverter
  case iso8601Converter
  case feetAndInchesConverter
  case timestampConverter
  case timespanConverter
  case laptimeConverter
  case timezoneConverter
  case roundingToDpConverter
  case roundingUpConverter
  case roundingConverter
  case roundingDownConverter
  case dateWordToday
  case dateWordNow
  case dateWordTomorrow
  case dateWordYesterday
  case dateWordDayOfWeek
  case dateWordMonthOfYear
  case dateWordQuarterOfYear
  case dateWordAm
  case dateWordPm
  case dateWordMidday
  case dateWordMidnight
  case dateWordSummer
  case dateWordAutumn
  case dateWordWinter
  case dateWordSpring
  case dateQualifierNext
  case dateQualifierPrevious
  case relativePlaceWordHere
  case numberWordHundred
  case numberWordThousand
  case numberWordMillion
  case numberWordBillion
  case numberWordTrillion
  case conjunctionWordAnd
  case conjunctionWordOr
  case numberTypeName
  case fractionTypeName
  case multiplierTypeName
  case binaryTypeName
  case hexadecimalTypeName
  case percentageTypeName
  case rateTypeName
  case timestampTypeName
  case timespanTypeName
  case feetAndInchesTypeName
  case laptimeTypeName
  case dateTypeName
  case iso8601TypeName
  case decimalPlacesTypeName
  case builtInWordFunction
  case customWordFunction
  case conditionalKeywordIf
  case conditionalKeywordThen
  case conditionalKeywordElse
  case conditionalKeywordUnless
  case unitMismatchError
  case infinityError
  case divideByZeroError
  case imaginaryNumberError
  case unsupportedUnitMultiplication
  case unsupportedRate
  case badDivision
  case unknownError
  case notSpecified
  public static func == (a: SoulverCore.TokenSubType, b: SoulverCore.TokenSubType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
indirect public enum EvaluationResult {
  case rawString(Swift.String)
  case decimal(Foundation.Decimal)
  case percentage(SoulverCore.Percentage)
  case fraction(SoulverCore.Fraction)
  case binary(Swift.Int)
  case hex(Swift.Int)
  case multiplier(SoulverCore.Multiplier)
  case boolean(Swift.Bool)
  case unitExpression(SoulverCore.UnitExpression)
  case rate(SoulverCore.UnitRate)
  case date(SoulverCore.Datestamp)
  case iso8601(SoulverCore.iso8601)
  case timestamp(SoulverCore.Timestamp)
  case timespan(SoulverCore.Timespan)
  case laptime(SoulverCore.Laptime)
  case error(SoulverCore.EvaluationError)
  case variable(SoulverCore.Variable)
  case unit(SoulverCore.SCUnit)
  case substance(SoulverCore.Substance)
  case datespan(SoulverCore.Datespan)
  case timezone(Foundation.TimeZone)
  case customType(SoulverCore.CustomType)
  case pending
  case failed
  case none
  public var stringValue: Swift.String? {
    get
  }
  public var equivalentTokenType: SoulverCore.TokenType {
    get
  }
  public var decimalValue: Foundation.Decimal? {
    get
  }
  public var unitExpressionValue: SoulverCore.UnitExpression? {
    get
  }
  public var datestampValue: SoulverCore.Datestamp? {
    get
  }
  public var unitValue: SoulverCore.SCUnit? {
    get
  }
  public var substanceValue: SoulverCore.Substance? {
    get
  }
  public var rateValue: SoulverCore.UnitRate? {
    get
  }
}
extension EvaluationResult : Swift.Equatable {
  public static func == (lhs: SoulverCore.EvaluationResult, rhs: SoulverCore.EvaluationResult) -> Swift.Bool
}
extension Token {
  public var number: Foundation.Decimal? {
    get
  }
  public var scalar: SoulverCore.Scalar? {
    get
  }
  public var decimalValue: Foundation.Decimal {
    get
  }
  public var binaryValue: Swift.Int? {
    get
  }
  public var hexValue: Swift.Int? {
    get
  }
  public var percentageValue: SoulverCore.Percentage {
    get
  }
  public var unitExpressionValue: SoulverCore.UnitExpression? {
    get
  }
  public var unitValue: SoulverCore.SCUnit? {
    get
  }
  public var calendarComponentValue: Foundation.Calendar.Component? {
    get
  }
  public var rateValue: SoulverCore.UnitRate? {
    get
  }
  public var datestampValue: SoulverCore.Datestamp? {
    get
  }
  public var datespanValue: SoulverCore.Datespan? {
    get
  }
  public var dateComponentsValue: Foundation.DateComponents? {
    get
  }
  public var timespanValue: SoulverCore.Timespan? {
    get
  }
  public var timeZoneValue: Foundation.TimeZone? {
    get
  }
  public var fractionValue: SoulverCore.Fraction? {
    get
  }
  public var laptimeValue: SoulverCore.Laptime? {
    get
  }
  public var errorValue: SoulverCore.EvaluationError? {
    get
  }
  public var variable: SoulverCore.Variable? {
    get
  }
  public var dynamicVariable: SoulverCore.DynamicVariable? {
    get
  }
  public var isLineReference: Swift.Bool {
    get
  }
  public var isVariable: Swift.Bool {
    get
  }
}
public class LineCollection {
  public typealias EvaluatedLinesHandler = (Foundation.IndexSet) -> Swift.Void
  public var lineSheet: SoulverCore.LineSheet {
    get
    set
  }
  public var customization: SoulverCore.EngineCustomization {
    get
  }
  public var defaultLineFormattingPreferences: SoulverCore.FormattingPreferences? {
    get
    set
  }
  public var expressionBeautificationOptions: SoulverCore.ExpressionBeautificationOptions? {
    get
    set
  }
  public init(customization: SoulverCore.EngineCustomization = EngineCustomization.standard)
  public var deepCopy: SoulverCore.LineCollection {
    get
  }
  public func beginChanges()
  public func endChangesWith(evaluationHandler: SoulverCore.LineCollection.EvaluatedLinesHandler?, dependenciesHandler: SoulverCore.LineCollection.EvaluatedLinesHandler?)
  @discardableResult
  public func addLine(_ expression: Swift.String = "") -> SoulverCore.Line
  public func setLinesWithExpressions(_ expressions: [SoulverCore.RawExpression])
  public func insertLineBelow(lineIndex: SoulverCore.LineIndex, with expression: Swift.String)
  public func insertLineAt(lineIndex: SoulverCore.LineIndex, withExpression expression: Swift.String)
  public func insert(line: SoulverCore.Line, at lineIndex: SoulverCore.LineIndex)
  public func moveLineAt(lineIndex: SoulverCore.LineIndex, toLineIndex: SoulverCore.LineIndex)
  public func removeLineAt(lineIndex: SoulverCore.LineIndex)
  public func replaceLineAt(lineIndex: SoulverCore.LineIndex, with newLine: SoulverCore.Line)
  public subscript(index: SoulverCore.LineIndex) -> SoulverCore.Line {
    get
    set(newValue)
  }
  public subscript(safe index: SoulverCore.LineIndex) -> SoulverCore.Line? {
    get
  }
  public func setExpression(expression: Swift.String, forLineAt index: SoulverCore.LineIndex)
  public func setFormatting(formattingPreferences: SoulverCore.FormattingPreferences)
  public func setFormatting(formattingPreferences: SoulverCore.FormattingPreferences?, forLineAt index: SoulverCore.LineIndex)
  public func setTags(tags: [Swift.String], forLineAt index: SoulverCore.LineIndex)
  public func setBehaviour(behaviour: SoulverCore.LineCalculationBehaviour, forLineAt index: SoulverCore.LineIndex)
  public func evaluateAll()
  public func evaluateLinesAt(indexes: Foundation.IndexSet, dependenciesUpdatedHandler: SoulverCore.LineCollection.EvaluatedLinesHandler? = nil)
  @discardableResult
  public func makeReferenceForLineAt(lineIndex: SoulverCore.LineIndex) -> SoulverCore.LineReference
  public func clearReferenceForLineAt(lineIndex: SoulverCore.LineIndex)
  @discardableResult
  public func observeEvaluationWith(handler: @escaping SoulverCore.LineCollection.EvaluatedLinesHandler) -> SoulverCore.LineCollectionObserverToken
  public func remove(observer: SoulverCore.LineCollectionObserverToken)
  public var quickSum: SoulverCore.CalculationResult? {
    get
  }
  public var quickAverage: SoulverCore.CalculationResult? {
    get
  }
  public var quickCount: SoulverCore.CalculationResult? {
    get
  }
  public func quickSumOf(indexes: Foundation.IndexSet) -> SoulverCore.CalculationResult?
  public func quickAverageOf(indexes: Foundation.IndexSet) -> SoulverCore.CalculationResult?
  public func quickCountOf(indexes: Foundation.IndexSet) -> SoulverCore.CalculationResult?
  @discardableResult
  public func convertToLocale(_ toLocale: Foundation.Locale) -> Swift.Bool
  public func set(customization: SoulverCore.EngineCustomization)
  public func performChanges(performBlock: ((SoulverCore.LineCollection) -> Swift.Void)) -> SoulverCore.LineCollectionStateTicket
  @discardableResult
  public func revertToStateWith(ticket: SoulverCore.LineCollectionStateTicket) -> SoulverCore.LineSheetDelta?
  public func clearStates()
  public var lineCount: Swift.Int {
    get
  }
  public func isValidIndex(_ lineIndex: SoulverCore.LineIndex) -> Swift.Bool
  public var allIndexes: Foundation.IndexSet {
    get
  }
  public var lastIndex: Swift.Int {
    get
  }
  public var firstIndex: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var lines: [SoulverCore.Line] {
    get
  }
  public func linesAtIndexes(indexes: Foundation.IndexSet) -> [SoulverCore.Line]
  public func variableListForLineAtIndex(_ lineIndex: SoulverCore.LineIndex) -> SoulverCore.VariableList
  public func tokenFor(tokenIndexPath: SoulverCore.TokenIndexPath) -> SoulverCore.Token?
  public func isValidLineReference(UID: SoulverCore.UID, onLineAt lineIndex: SoulverCore.LineIndex) -> Swift.Bool
  public func lineForLineReference(lineReference: SoulverCore.LineReference) -> SoulverCore.Line?
  public func lineFor(_ lineReferenceVariable: SoulverCore.Variable) -> SoulverCore.Line?
  public func formattedDefinitionOf(inlineVariable: SoulverCore.Variable) -> Swift.String?
  @discardableResult
  public func replaceOccurancesInExpressions(replacements: [Swift.String : Swift.String]) -> Foundation.IndexSet
  public func unformattedResultFor(lineIndex: SoulverCore.LineIndex) -> Swift.String
  public var customEvaluator: SoulverCore.Evaluator? {
    get
    set
  }
  public func addSubsheet() -> SoulverCore.LineReference
  public func set(content lineSheet: SoulverCore.LineSheet, forSubsheetWith reference: SoulverCore.LineReference)
  public func contentForSubsheetWith(reference: SoulverCore.LineReference) -> SoulverCore.LineSheet?
  public func makeReferenceForDynamicSymbol() -> SoulverCore.LineReference
  @objc deinit
}
public typealias LineCollectionStateTicket = Swift.String
extension LineCollection : Swift.CustomDebugStringConvertible {
  public typealias MultiLineText = Swift.String
  public class func textViewReadyLineCollectionWith(customization: SoulverCore.EngineCustomization) -> SoulverCore.LineCollection
  convenience public init(multiLineText: SoulverCore.LineCollection.MultiLineText, customization: SoulverCore.EngineCustomization? = nil)
  public var debugDescription: Swift.String {
    get
  }
}
extension LineCollection {
  public var engineCustomization: SoulverCore.EngineCustomization {
    get
  }
  public func finishLineCollectionSetup(lineCollection: SoulverCore.LineCollection)
}
@_hasMissingDesignatedInitializers public class LineCollectionObserverToken : Swift.Hashable, Swift.Equatable {
  public static func == (lhs: SoulverCore.LineCollectionObserverToken, rhs: SoulverCore.LineCollectionObserverToken) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension LineCollection {
  public var indexesOfTimeDependentLines: Foundation.IndexSet {
    get
  }
  public func indexesOfLinesDependentOn(variables: [SoulverCore.Variable]) -> Foundation.IndexSet
  public var indexesOfPendingLines: Foundation.IndexSet {
    get
  }
}
@_hasMissingDesignatedInitializers public class LineCollectionIterator : Swift.IteratorProtocol {
  public typealias Element = SoulverCore.Line
  public func next() -> SoulverCore.Line?
  @objc deinit
}
extension LineCollection : Swift.Sequence {
  public func makeIterator() -> SoulverCore.LineCollectionIterator
  public typealias Element = SoulverCore.LineCollectionIterator.Element
  public typealias Iterator = SoulverCore.LineCollectionIterator
}
extension LineCollection {
  public var text: SoulverCore.LineCollection.MultiLineText {
    get
  }
}
public struct ExpressionBeautificationOptions {
  public var quickOperators: Swift.Bool
  public var autoThousandsSeparators: Swift.Bool
  public var allowsOrphanedThousandsSeparators: Swift.Bool
  public var padStandardOperators: Swift.Bool
  public var fancyTimes: Swift.Bool
  public var fancyMinus: Swift.Bool
  public var collapseSpaces: Swift.Bool
  public var formatsSlashCommentsWithSpaces: Swift.Bool
  public static var defaults: SoulverCore.ExpressionBeautificationOptions {
    get
  }
  public init()
}
public struct Timestamp : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public static func == (a: SoulverCore.Timestamp, b: SoulverCore.Timestamp) -> Swift.Bool
}
extension _NSRange {
  public static var zero: Foundation.NSRange {
    get
  }
}
public struct TokenTypeSet {
  public init(types: Swift.Set<SoulverCore.TokenType>)
  public let types: Swift.Set<SoulverCore.TokenType>
  public func contains(_ tokenType: SoulverCore.TokenType) -> Swift.Bool
  public static let randomWords: SoulverCore.TokenTypeSet
}
public enum LineStyle : Swift.Int {
  case normal
  case heading
  case label
  case comment
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public class LineStyler {
  public static let MARKDOWN_HEADING_CHARACTER: Swift.String
  public static let HEADING_INDICATOR: Swift.String
  public static let COMMENT_INDICATOR: Swift.String
  public static let LABEL_INDICATOR: Swift.String
  public init()
  public func lineStyleFor(expression: Swift.String) -> SoulverCore.LineStyle
  public func style(expression: Swift.String, with style: SoulverCore.LineStyle) -> Swift.String
  public func entireLabelRangeIn(_ expression: Swift.String) -> Foundation.NSRange?
  public func labelRangeIn(_ expression: Swift.String) -> Foundation.NSRange?
  public func headingIndicatorRangeIn(_ expression: Swift.String) -> Foundation.NSRange?
  public func headingRangeIn(_ expression: Swift.String) -> Foundation.NSRange?
  public var defaultLabel: Swift.String {
    get
  }
  @objc deinit
}
public enum UnitSymbolReplacementPosition : Swift.String, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable {
  case before
  case beforeWithSpace
  case after
  case afterWithSpace
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias AllCases = [SoulverCore.UnitSymbolReplacementPosition]
  public static var allCases: [SoulverCore.UnitSymbolReplacementPosition] {
    get
  }
}
public struct UnitSymbolReplacement : Swift.Equatable, Swift.Hashable, Swift.Codable {
  public let originalSymbol: Swift.String
  public let replacementSymbol: Swift.String
  public let position: SoulverCore.UnitSymbolReplacementPosition
  public init(original: Swift.String, replacement: Swift.String, position: SoulverCore.UnitSymbolReplacementPosition = .before)
  public static func standardCustomSymbolsFor(locale: Foundation.Locale) -> [SoulverCore.UnitSymbolReplacement]
  public init(from decoder: Swift.Decoder) throws
  public static func == (a: SoulverCore.UnitSymbolReplacement, b: SoulverCore.UnitSymbolReplacement) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
}
public struct CustomUnit : Swift.Hashable, Swift.Equatable, Swift.Codable {
  public let name: Swift.String
  public let definition: Foundation.Decimal
  public let equivalentUnit: SoulverCore.UnitIdentifier
  public let legacyDefinition: Swift.String?
  public init(name: Swift.String, definition: Foundation.Decimal, equivalentUnit: SoulverCore.UnitIdentifier)
  public init(from decoder: Swift.Decoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.CustomUnit, b: SoulverCore.CustomUnit) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
}
extension Array where Element : Swift.Equatable {
  public func doesNotContain(_ element: Element) -> Swift.Bool
}
extension Collection {
  public var isNotEmpty: Swift.Bool {
    get
  }
}
extension Array {
  public subscript(safe index: Swift.Array<Element>.Index) -> Element? {
    get
  }
  public var lastIndex: Swift.Int? {
    get
  }
  public func isValid(index: Swift.Int) -> Swift.Bool
  public mutating func trim(where predicate: (Element) throws -> Swift.Bool)
  public mutating func move(from oldIndex: Swift.Array<Element>.Index, to newIndex: Swift.Array<Element>.Index)
}
infix operator ~ : AdditionPrecedence
public struct WordFunctionArgument {
  public let matchedToken: SoulverCore.Token
  public let functionArgument: SoulverCore.EvaluationResult
}
@_hasMissingDesignatedInitializers public class FunctionSubstitutionUtility {
  public class func functionArgumentsForCustomFunction(token: SoulverCore.Token) -> [SoulverCore.WordFunctionArgument]?
  @objc deinit
}
public let UntokenizedLineReference: Swift.String
public enum UnitMeasurementSystem : Swift.String, Swift.RawRepresentable, Swift.Equatable {
  case customaryUS
  case imperial
  case metric
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct Multiplier : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public static func == (a: SoulverCore.Multiplier, b: SoulverCore.Multiplier) -> Swift.Bool
}
open class StandardEvaluator : SoulverCore.Evaluator {
  public init(customization: SoulverCore.EngineCustomization)
  open func evaluate(_ tokenList: SoulverCore.TokenList) -> SoulverCore.EvaluationResult
  public func preprocessed(tokenList: SoulverCore.TokenList) -> SoulverCore.TokenList
  public func expressionForEvaluationFrom(tokenList: SoulverCore.TokenList) -> SoulverCore.RawExpression
  public func evaluationResultFor(resultString: Swift.String) -> SoulverCore.EvaluationResult
  public func evaluationResultFor(string: Swift.String, with variables: SoulverCore.VariableList) -> SoulverCore.EvaluationResult
  @objc deinit
}
public protocol TokenMetadata {
}
public struct DynamicVariableTokenMetadata : SoulverCore.TokenMetadata {
  public let dynamicVariable: SoulverCore.DynamicVariable
  public let value: SoulverCore.CalculationResult
}
public enum SIThreshold : Swift.String {
  case septillion
  case sextillion
  case quintillion
  case quadrillion
  case trillion
  case billion
  case million
  case hundredThousand
  case thousand
  case hecto
  case deca
  case centi
  case milli
  case micro
  case nano
  case pico
  case femto
  case atto
  case zetto
  case yocto
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct LineSheetDelta {
  public let indexesAdded: Foundation.IndexSet
  public let indexesDeleted: Foundation.IndexSet
  public let indexesModified: Foundation.IndexSet
  public var isSingleLineEdit: Swift.Bool {
    get
  }
}
@_hasMissingDesignatedInitializers public class LineCollectionEnumerator {
  public typealias EnumerationExpression = Swift.String
  public typealias EnumerationResult = Swift.String
  public enum ReferenceSubstituionPolicy {
    case dontSubstitue
    case formattedResult
    case plainTextReference
    case markdownLinkStyle
    public static func == (a: SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy, b: SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum ResultFormatting {
    case formatted
    case raw
    public static func == (a: SoulverCore.LineCollectionEnumerator.ResultFormatting, b: SoulverCore.LineCollectionEnumerator.ResultFormatting) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public struct LineCollectionEnumerationOptions {
    public var referenceSubstitutionPolicy: SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy
    public var resultFormatting: SoulverCore.LineCollectionEnumerator.ResultFormatting
    public var reversed: Swift.Bool
    public init()
  }
  public typealias LineCollectionStringEnumerationHandler = ((SoulverCore.LineIndex, SoulverCore.LineCollectionEnumerator.EnumerationExpression, SoulverCore.LineCollectionEnumerator.EnumerationResult, inout Swift.Bool) -> Swift.Void)
  public typealias LineCollectionModelEnumerationHandler = ((SoulverCore.LineIndex, SoulverCore.TokenList, SoulverCore.CalculationResult?, inout Swift.Bool) -> Swift.Void)
  public class func enumerateStringsIn(lineCollection: SoulverCore.LineCollection, with options: SoulverCore.LineCollectionEnumerator.LineCollectionEnumerationOptions = LineCollectionEnumerationOptions(), in handler: (SoulverCore.LineIndex, SoulverCore.LineCollectionEnumerator.EnumerationExpression, SoulverCore.LineCollectionEnumerator.EnumerationResult, inout Swift.Bool) -> Swift.Void)
  public class func enumerateModelsIn(lineCollection: SoulverCore.LineCollection, with options: SoulverCore.LineCollectionEnumerator.LineCollectionEnumerationOptions = LineCollectionEnumerationOptions(), in modelHandler: (SoulverCore.LineIndex, SoulverCore.TokenList, SoulverCore.CalculationResult?, inout Swift.Bool) -> Swift.Void)
  public class func enumerateStringsIn<T>(lineCollection: SoulverCore.LineCollection, with options: SoulverCore.LineCollectionEnumerator.LineCollectionEnumerationOptions = LineCollectionEnumerationOptions(), in handler: ((SoulverCore.LineIndex, SoulverCore.LineCollectionEnumerator.EnumerationExpression, SoulverCore.LineCollectionEnumerator.EnumerationResult) -> T?)) -> T?
  @objc deinit
}
public struct EngineFeatureFlags : Swift.Equatable, Swift.Hashable, Swift.Codable {
  public var calendarCalculations: Swift.Bool
  public var units: Swift.Bool
  public var wordFunctions: Swift.Bool
  public var variableDeclarations: Swift.Bool
  public var hexAndBinary: Swift.Bool
  public var cookingSubstances: Swift.Bool
  public var bracketComments: Swift.Bool
  public var inAmbiguityPreferSomethingToNothing: Swift.Bool
  public var seeksFutureDate: Swift.Bool
  public var leftToRightOperatorEvaluation: Swift.Bool
  public init()
  public init(units: Swift.Bool, wordFunctions: Swift.Bool, variableDeclarations: Swift.Bool, bracketComments: Swift.Bool, calendarCalculations: Swift.Bool, leftToRightOperatorEvaluation: Swift.Bool, inAmbiguityPreferSomethingToNothing: Swift.Bool)
  public init(from decoder: Swift.Decoder) throws
  public static func == (a: SoulverCore.EngineFeatureFlags, b: SoulverCore.EngineFeatureFlags) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Fraction : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public let unitValue: SoulverCore.SCUnit?
  public static func == (a: SoulverCore.Fraction, b: SoulverCore.Fraction) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class SCUnit : Swift.Equatable, Swift.Hashable {
  final public let identifier: SoulverCore.UnitIdentifier
  final public let symbol: Swift.String
  public var baseUnitValue: Foundation.Decimal {
    get
  }
  public var baseUnit: SoulverCore.SCUnit {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: SoulverCore.SCUnit, rhs: SoulverCore.SCUnit) -> Swift.Bool
  open class func baseUnit() -> SoulverCore.SCUnit
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension SCUnit {
  public var unitType: SoulverCore.UnitType {
    get
  }
}
public typealias PrivateUnicodeSymbol = Swift.String
@_hasMissingDesignatedInitializers public class SingleCharacterUIDGenerator {
  public class func isUID(symbol: SoulverCore.PrivateUnicodeSymbol) -> Swift.Bool
  @objc deinit
}
extension Decimal {
  public var doubleValue: Swift.Double {
    get
  }
}
public struct Country : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public let name: Swift.String
  public let capital: Swift.String
  public let capitalCityTimezoneID: Swift.String?
  public var timeZone: Foundation.TimeZone? {
    get
  }
  public static func == (a: SoulverCore.Country, b: SoulverCore.Country) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct City : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public let identifier: Swift.String
  public let name: Swift.String
  public let timezone_id: Swift.String
  public var timeZone: Foundation.TimeZone? {
    get
  }
  public static func == (a: SoulverCore.City, b: SoulverCore.City) -> Swift.Bool
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class LocaleProvider {
  public class func localeWith(identifier: Swift.String) -> Foundation.Locale
  @objc deinit
}
public enum EvaluationError : Swift.Error {
  case UnitMismatch
  case UnsupportedUnitMultiplication
  case UnsupportedRate
  case Infinity
  case ImaginaryNumber
  case DivideByZero
  case BadDivision
  case Other
  public static func == (a: SoulverCore.EvaluationError, b: SoulverCore.EvaluationError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum TokenListForm : Swift.Equatable {
  case singleNumber(value: Foundation.Decimal)
  case singleUnitExpression(value: SoulverCore.UnitExpression)
  case singleDatestamp(value: SoulverCore.Datestamp)
  case conversion(fromUnit: SoulverCore.SCUnit, toUnit: SoulverCore.SCUnit, quantity: Foundation.Decimal)
  case dateSeeking(startDate: SoulverCore.Datestamp, timespan: SoulverCore.Timespan, direction: Foundation.Calendar.SearchDirection)
  case unitUntilDateSeeking(unit: SoulverCore.SCUnit, toDate: SoulverCore.Datestamp)
  case intervalBetweenDatesSeeking(startDate: SoulverCore.Datestamp, endDate: SoulverCore.Datestamp, unit: SoulverCore.SCUnit?)
  case timeAtPlaceSeeking(place: SoulverCore.Place)
  case timeDifferenceBetweenPlacesSeeking(firstPlace: SoulverCore.Place, secondPlace: SoulverCore.Place)
  case timeConversionToPlace(fromDate: SoulverCore.Datestamp, toPlace: SoulverCore.Place)
  case other
  public static func == (a: SoulverCore.TokenListForm, b: SoulverCore.TokenListForm) -> Swift.Bool
}
public struct TokenListMetadata {
  public let form: SoulverCore.TokenListForm
}
extension TokenList {
  public var metadata: SoulverCore.TokenListMetadata {
    get
  }
}
public struct NotationPreferences : Swift.Equatable, Swift.Hashable {
  public enum NotationStyle {
    case auto
    case on
    case off
    public static func == (a: SoulverCore.NotationPreferences.NotationStyle, b: SoulverCore.NotationPreferences.NotationStyle) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var notationStyle: SoulverCore.NotationPreferences.NotationStyle
  public var upperNotationThreshold: SoulverCore.SIThreshold
  public var lowerNotationThreshold: SoulverCore.SIThreshold
  public init(notationStyle: SoulverCore.NotationPreferences.NotationStyle, upperNotationThreshold: SoulverCore.SIThreshold, lowerNotationThreshold: SoulverCore.SIThreshold)
  public static func == (a: SoulverCore.NotationPreferences, b: SoulverCore.NotationPreferences) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct FormattingPreferences : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public static var maximumDp: Swift.Int
  public var dp: Swift.Int
  public var thousandsSeparatorDisabled: Swift.Bool
  public var currencyFormattingDisabled: Swift.Bool
  public var implicitUnitsDisabled: Swift.Bool
  public var notationPreferences: SoulverCore.NotationPreferences
  public var referencesTakeFormattedValue: Swift.Bool
  public var fractionizeWherePossible: Swift.Bool
  public init()
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: SoulverCore.FormattingPreferences, b: SoulverCore.FormattingPreferences) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct UnitDescription : Swift.Hashable, Swift.Codable {
  public init(unit: SoulverCore.SCUnit, symbol: Swift.String, aliases: [Swift.String])
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.UnitDescription, b: SoulverCore.UnitDescription) -> Swift.Bool
}
public typealias PrototypeExpression = Swift.String
public enum PrototypeExpressionMatchType {
  case matchLiteralString
  case matchTokenType
  case matchUnitType
  public static func == (a: SoulverCore.PrototypeExpressionMatchType, b: SoulverCore.PrototypeExpressionMatchType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public typealias PrototypeExpressionMatchTypeHandler = (SoulverCore.Token) -> SoulverCore.PrototypeExpressionMatchType
@_hasMissingDesignatedInitializers public class PrototypeExpressionGenerator {
  public class func prototypeStringFrom(expression: SoulverCore.RawExpression, matchTypeHandler: (SoulverCore.Token) -> SoulverCore.PrototypeExpressionMatchType) -> SoulverCore.PrototypeExpression
  @objc deinit
}
extension String {
  public func foundationLocalized() -> Swift.String
  public func localized(bundle: Foundation.Bundle = .main) -> Swift.String
}
public struct Holiday : Swift.Hashable, Swift.Equatable {
  public init(day: Swift.Int, month: Swift.Int, year: Swift.Int)
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SoulverCore.Holiday, b: SoulverCore.Holiday) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers open class AsynchronousOperation : Foundation.Operation {
  @objc override dynamic public var isAsynchronous: Swift.Bool {
    @objc get
  }
  @objc override dynamic public var isExecuting: Swift.Bool {
    @objc get
  }
  @objc override dynamic public var isFinished: Swift.Bool {
    @objc get
  }
  @objc override dynamic public func start()
  @objc override dynamic open func main()
  public func finish()
  public enum State : Swift.String {
    case ready
    case executing
    case finished
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var state: SoulverCore.AsynchronousOperation.State {
    get
    set
  }
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ResultContextualMetadata {
  public class func humanReadableMetadataFor(formattedResult: SoulverCore.CalculationResult, customization: SoulverCore.EngineCustomization) -> Swift.String?
  @objc deinit
}
public struct iso8601 : Swift.Equatable {
  public let datestamp: SoulverCore.Datestamp
  public static func == (a: SoulverCore.iso8601, b: SoulverCore.iso8601) -> Swift.Bool
}
public struct Timespan : Swift.Equatable {
  public let dateComponents: Foundation.DateComponents
  public static func == (a: SoulverCore.Timespan, b: SoulverCore.Timespan) -> Swift.Bool
}
public typealias LineIndex = Swift.Int
@_hasMissingDesignatedInitializers public class LineSheet : Swift.Codable {
  public var copy: SoulverCore.LineSheet {
    get
  }
  public var allLineReferences: [SoulverCore.LineIndex : SoulverCore.LineReference] {
    get
  }
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
extension SoulverCore.DatespanType : Swift.Equatable {}
extension SoulverCore.DatespanType : Swift.Hashable {}
extension SoulverCore.DatespanSubtype : Swift.Equatable {}
extension SoulverCore.DatespanSubtype : Swift.Hashable {}
extension SoulverCore.UnitType : Swift.Equatable {}
extension SoulverCore.UnitType : Swift.Hashable {}
extension SoulverCore.UnitType : Swift.RawRepresentable {}
extension SoulverCore.UnitIdentifier : Swift.Equatable {}
extension SoulverCore.UnitIdentifier : Swift.Hashable {}
extension SoulverCore.ApparentLineType : Swift.Equatable {}
extension SoulverCore.ApparentLineType : Swift.Hashable {}
extension SoulverCore.LineCalculationBehaviour : Swift.Equatable {}
extension SoulverCore.LineCalculationBehaviour : Swift.Hashable {}
extension SoulverCore.LineCalculationBehaviour : Swift.RawRepresentable {}
extension SoulverCore.CurrencySet : Swift.Equatable {}
extension SoulverCore.CurrencySet : Swift.Hashable {}
extension SoulverCore.CurrencySet : Swift.RawRepresentable {}
extension SoulverCore.VariableType : Swift.Equatable {}
extension SoulverCore.VariableType : Swift.Hashable {}
extension SoulverCore.DynamicVariable.DynamicVariableType : Swift.Equatable {}
extension SoulverCore.DynamicVariable.DynamicVariableType : Swift.Hashable {}
extension SoulverCore.DatestampType : Swift.Equatable {}
extension SoulverCore.DatestampType : Swift.Hashable {}
extension SoulverCore.TokenType : Swift.Equatable {}
extension SoulverCore.TokenType : Swift.Hashable {}
extension SoulverCore.TokenSubType : Swift.Equatable {}
extension SoulverCore.TokenSubType : Swift.Hashable {}
extension SoulverCore.LineStyle : Swift.Equatable {}
extension SoulverCore.LineStyle : Swift.Hashable {}
extension SoulverCore.LineStyle : Swift.RawRepresentable {}
extension SoulverCore.UnitSymbolReplacementPosition : Swift.Equatable {}
extension SoulverCore.UnitSymbolReplacementPosition : Swift.Hashable {}
extension SoulverCore.UnitMeasurementSystem : Swift.Hashable {}
extension SoulverCore.SIThreshold : Swift.Equatable {}
extension SoulverCore.SIThreshold : Swift.Hashable {}
extension SoulverCore.SIThreshold : Swift.RawRepresentable {}
extension SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy : Swift.Equatable {}
extension SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy : Swift.Hashable {}
extension SoulverCore.LineCollectionEnumerator.ResultFormatting : Swift.Equatable {}
extension SoulverCore.LineCollectionEnumerator.ResultFormatting : Swift.Hashable {}
extension SoulverCore.EvaluationError : Swift.Equatable {}
extension SoulverCore.EvaluationError : Swift.Hashable {}
extension SoulverCore.NotationPreferences.NotationStyle : Swift.Equatable {}
extension SoulverCore.NotationPreferences.NotationStyle : Swift.Hashable {}
extension SoulverCore.PrototypeExpressionMatchType : Swift.Equatable {}
extension SoulverCore.PrototypeExpressionMatchType : Swift.Hashable {}
extension SoulverCore.AsynchronousOperation.State : Swift.Equatable {}
extension SoulverCore.AsynchronousOperation.State : Swift.Hashable {}
extension SoulverCore.AsynchronousOperation.State : Swift.RawRepresentable {}
